
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Pinterest</title>
      <script type="module" crossorigin src="/dweb-rh/assets/index-BLL-NyY1.js"></script>
      <link rel="stylesheet" crossorigin href="/dweb-rh/assets/index-I0l3_rlN.css">
      <!-- Updated paths for GitHub Pages -->
    </head>

  <body>
    <div id="root"></div>
    <script>
      // Fix image paths for GitHub Pages
      (function() {
        const basePath = '/dweb-rh';
        
        function fixImageSrc(img) {
          if (!img) return;
          // Check src, data-src, and other lazy loading attributes
          let src = img.getAttribute('src') || 
                    img.getAttribute('data-src') || 
                    img.getAttribute('data-lazy-src') ||
                    img.src || '';
          
          // Remove domain if present to get just the path
          try {
            const url = new URL(src, window.location.origin);
            src = url.pathname;
          } catch(e) {
            // Not a full URL, use as is
            if (src && !src.startsWith('/') && !src.startsWith('http')) {
              // Relative path, skip
              return false;
            }
          }
          
          if (src && src.startsWith('/assets/') && !src.startsWith(basePath)) {
            const fixedSrc = basePath + src;
            // Fix all possible attributes
            if (img.getAttribute('src')) img.setAttribute('src', fixedSrc);
            if (img.getAttribute('data-src')) img.setAttribute('data-src', fixedSrc);
            if (img.getAttribute('data-lazy-src')) img.setAttribute('data-lazy-src', fixedSrc);
            img.src = fixedSrc;
            return true;
          }
          return false;
        }
        
        // Override src property setter on HTMLImageElement prototype - more aggressive
        const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
        if (originalSrcDescriptor && originalSrcDescriptor.set) {
          const originalSet = originalSrcDescriptor.set;
          Object.defineProperty(HTMLImageElement.prototype, 'src', {
            set: function(value) {
              if (value && typeof value === 'string') {
                let path = value;
                try {
                  const url = new URL(value, window.location.origin);
                  path = url.pathname;
                } catch(e) {
                  // Not a full URL, check if it's a relative path
                  if (value.startsWith('/')) {
                    path = value;
                  }
                }
                if (path && path.startsWith('/assets/') && !path.startsWith(basePath)) {
                  value = basePath + path;
                }
              }
              originalSet.call(this, value);
            },
            get: originalSrcDescriptor.get,
            configurable: true,
            enumerable: true
          });
        }
        
        // Also override data-src and other lazy loading attributes
        const originalSetAttribute = Element.prototype.setAttribute;
        Element.prototype.setAttribute = function(name, value) {
          if (this.tagName === 'IMG' && (name === 'src' || name === 'data-src' || name === 'data-lazy-src')) {
            if (value && typeof value === 'string') {
              let path = value;
              try {
                const url = new URL(value, window.location.origin);
                path = url.pathname;
              } catch(e) {
                if (value.startsWith('/')) {
                  path = value;
                }
              }
              if (path && path.startsWith('/assets/') && !path.startsWith(basePath)) {
                value = basePath + path;
              }
            }
          }
          return originalSetAttribute.call(this, name, value);
        };
        
        // Fix images that are already in the DOM
        function fixImagePaths() {
          const images = document.querySelectorAll('img');
          images.forEach(fixImageSrc);
        }
        
        // Override Image constructor to fix dynamically created images
        const OriginalImage = window.Image;
        window.Image = function(...args) {
          const img = new OriginalImage(...args);
          if (args.length > 0 && typeof args[0] === 'string') {
            const src = args[0];
            if (src.startsWith('/assets/') && !src.startsWith(basePath)) {
              img.src = basePath + src;
            }
          }
          return img;
        };
        
        // Watch for new images being added - more aggressive
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.nodeType === 1) { // Element node
                if (node.tagName === 'IMG') {
                  fixImageSrc(node);
                  // Also check for data-src that might be converted later
                  setTimeout(() => fixImageSrc(node), 0);
                  setTimeout(() => fixImageSrc(node), 50);
                  setTimeout(() => fixImageSrc(node), 100);
                }
                // Check child images
                const images = node.querySelectorAll && node.querySelectorAll('img');
                if (images) {
                  images.forEach(img => {
                    fixImageSrc(img);
                    setTimeout(() => fixImageSrc(img), 0);
                    setTimeout(() => fixImageSrc(img), 50);
                    setTimeout(() => fixImageSrc(img), 100);
                  });
                }
              }
            });
          });
        });
        
        // Fix existing images
        fixImagePaths();
        
        // Watch for new images
        observer.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['src']
        });
        
        // Also fix images on attribute changes - watch for src, data-src, etc.
        const attrObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            const attrName = mutation.attributeName;
            if (mutation.type === 'attributes' && 
                (attrName === 'src' || attrName === 'data-src' || attrName === 'data-lazy-src')) {
              fixImageSrc(mutation.target);
            }
          });
        });
        
        // Watch for src attribute changes on all images - including data-src
        function observeAllImages() {
          const allImages = document.querySelectorAll('img');
          allImages.forEach(img => {
            attrObserver.observe(img, { 
              attributes: true, 
              attributeFilter: ['src', 'data-src', 'data-lazy-src'] 
            });
            fixImageSrc(img);
          });
        }
        
        document.addEventListener('DOMContentLoaded', observeAllImages);
        
        // Periodic check to catch images that might be missed (more frequent)
        setInterval(function() {
          fixImagePaths();
        }, 500);
        
        // Also check after delays to catch React-rendered images
        setTimeout(fixImagePaths, 100);
        setTimeout(fixImagePaths, 300);
        setTimeout(fixImagePaths, 500);
        setTimeout(fixImagePaths, 1000);
        setTimeout(fixImagePaths, 2000);
        setTimeout(fixImagePaths, 3000);
        
        // Watch for scroll events (lazy loading)
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(fixImagePaths, 100);
        }, { passive: true });
        
        // Watch for intersection observer (common for lazy loading)
        const originalIntersectionObserver = window.IntersectionObserver;
        window.IntersectionObserver = function(callback, options) {
          const wrappedCallback = function(entries, observer) {
            // Fix images before callback runs
            setTimeout(fixImagePaths, 0);
            return callback(entries, observer);
          };
          return new originalIntersectionObserver(wrappedCallback, options);
        };
      })();
      
      // Make boards icon clickable - wait for React app to render
      (function() {
        let boardsIcon = null;
        let attempts = 0;
        const maxAttempts = 50; // Try for 5 seconds
        
        function findBoardsIcon() {
          // Look for nav element
          const nav = document.querySelector('[class*="GlobalNav"]') || 
                     document.querySelector('nav') ||
                     document.querySelector('[class*="globalNav"]');
          
          if (!nav) return null;
          
          // Get all clickable elements in nav
          const clickables = nav.querySelectorAll('button, [role="button"], a, div[class*="iconButton"], div[class*="IconButton"]');
          
          for (let el of clickables) {
            // Check text content
            const text = (el.textContent || el.innerText || '').trim();
            const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();
            const title = (el.getAttribute('title') || '').toLowerCase();
            
            // Check if this is the boards icon
            if (text === 'Boards' || ariaLabel.includes('boards') || title.includes('boards')) {
              return el;
            }
            
            // Check parent element
            const parent = el.parentElement;
            if (parent) {
              const parentText = (parent.textContent || parent.innerText || '').trim();
              if (parentText === 'Boards') {
                return parent;
              }
            }
          }
          
          // Alternative: look for icon by position (4th icon in leading section)
          const leading = nav.querySelector('[class*="leading"]') || nav.querySelector('[class*="Leading"]');
          if (leading) {
            const icons = leading.querySelectorAll('button, [role="button"], a, div[class*="iconButton"], div[class*="IconButton"]');
            // Boards is typically the 4th icon (index 3: Pinterest, Home, Explore, Boards)
            if (icons.length >= 4) {
              return icons[3];
            }
          }
          
          return null;
        }
        
        function attachClickHandler() {
          if (boardsIcon) return; // Already attached
          
          boardsIcon = findBoardsIcon();
          
          if (boardsIcon) {
            boardsIcon.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              window.location.href = '/dweb-rh/boards.html';
              return false;
            });
            boardsIcon.style.cursor = 'pointer';
            console.log('Boards icon click handler attached');
            return true;
          }
          
          return false;
        }
        
        // Try immediately
        if (!attachClickHandler()) {
          // Use MutationObserver to watch for DOM changes
          const observer = new MutationObserver(function() {
            attempts++;
            if (attachClickHandler() || attempts >= maxAttempts) {
              observer.disconnect();
            }
          });
          
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
          
          // Also try on intervals as fallback
          const interval = setInterval(function() {
            attempts++;
            if (attachClickHandler() || attempts >= maxAttempts) {
              clearInterval(interval);
              observer.disconnect();
            }
          }, 100);
        }
      })();
    </script>
  </body>
</html>
  