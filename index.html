
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Pinterest</title>
      <script type="module" crossorigin src="/dweb-rh/assets/index-BLL-NyY1.js"></script>
      <link rel="stylesheet" crossorigin href="/dweb-rh/assets/index-I0l3_rlN.css">
      <!-- Updated paths for GitHub Pages -->
      <style>
      /* All SearchBars - no margin, wrapper handles spacing */
      .SearchBar-module__searchBar {
        margin-bottom: 0 !important;
      }
      /* Enable scrolling even when SearchBar is expanded */
      body, html {
        overflow-y: auto !important;
        overflow-x: hidden !important;
        height: auto !important;
        position: static !important;
      }
      #root {
        overflow-y: auto !important;
        overflow-x: hidden !important;
        height: auto !important;
        position: static !important;
      }
      /* Ensure main content containers allow scrolling */
      .App-module__main,
      .HomePage-module__homePage,
      [class*="homePage"],
      [class*="mainContent"] {
        overflow-y: auto !important;
        overflow-x: hidden !important;
        height: auto !important;
      }
      /* Prevent any modal/overlay from blocking interaction */
      .SearchBar-module__searchBar.SearchBar-module__expanded ~ *,
      .ScrollableSearchBar-module__searchBarWrapper ~ * {
        pointer-events: auto !important;
      }
      /* CRITICAL: Allow scroll events to pass through the focus overlay */
      .ScrollableSearchBar-module__focusOverlay {
        pointer-events: none !important;
        touch-action: auto !important;
      }
      /* But keep the SearchBar itself clickable */
      .SearchBar-module__searchBar,
      .SearchBar-module__inputRow,
      .SearchBar-module__searchInput,
      .SearchHelperCard-module__helperCard {
        pointer-events: auto !important;
      }
      /* ScrollableSearchBar scroll behavior - wrapper positioning */
      .ScrollableSearchBar-module__searchBarWrapper {
        position: fixed !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 21px !important;
        z-index: 1000 !important;
        margin: 0 !important;
        padding: 0 !important;
        box-sizing: border-box !important;
        font-family: "Pin Sans", -apple-system, "system-ui", "Segoe UI", sans-serif !important;
        font-size: 12.25px !important;
        font-weight: 400 !important;
        line-height: 18.375px !important;
        color: rgb(3, 2, 19) !important;
        pointer-events: none !important;
        transition-property: transform, opacity !important;
        transition-duration: 0.3s, 0.3s !important;
        transition-timing-function: ease-out, ease-out !important;
        -webkit-font-smoothing: antialiased !important;
      }
      /* Hide wrapper when data-scroll-collapsed="true" */
      .ScrollableSearchBar-module__searchBarWrapper[data-scroll-collapsed="true"] {
        transform: none !important;
        opacity: 0.5 !important;
      }
      /* Restore full opacity on hover when partially hidden */
      .ScrollableSearchBar-module__searchBarWrapper[data-scroll-collapsed="true"]:hover {
        transform: none !important;
        opacity: 1 !important;
      }
      /* Collapsed SearchBar state - matches inputRow styling */
      .SearchBar-module__searchBar.SearchBar-module__collapsed {
        display: flex !important;
        align-items: flex-start !important;
        box-sizing: border-box !important;
        width: 380px !important;
        min-width: 380px !important;
        max-width: 380px !important;
        height: 108px !important;
        min-height: 108px !important;
        max-height: 108px !important;
        padding: 0 0 0 16px !important;
        position: relative !important;
        column-gap: 12px !important;
        row-gap: 12px !important;
        background: #ffffff !important;
        border-radius: 16px !important;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
        cursor: pointer !important;
        pointer-events: auto !important;
        font-family: "Pin Sans", -apple-system, "system-ui", "Segoe UI", sans-serif !important;
        font-size: 12.25px !important;
        font-weight: 400 !important;
        line-height: 18.375px !important;
        color: rgb(3, 2, 19) !important;
        -webkit-font-smoothing: antialiased !important;
        flex-shrink: 0 !important;
      }
      .SearchBar-module__searchBar.SearchBar-module__collapsed .SearchBar-module__hStack {
        display: flex !important;
        align-items: center !important;
        height: auto !important;
        padding: 0 !important;
        column-gap: 12px !important;
        width: 100% !important;
      }
      .SearchBar-module__searchBar.SearchBar-module__collapsed .SearchBar-module__vStack {
        display: flex !important;
        align-items: flex-start !important;
        gap: 0 !important;
        height: auto !important;
        width: 100% !important;
      }
      /* Hide helper cards in collapsed state */
      .SearchBar-module__searchBar.SearchBar-module__collapsed .SearchHelperCards-module__helperCardsContainer {
        display: none !important;
        visibility: hidden !important;
        height: 0 !important;
        overflow: hidden !important;
      }
      /* Show helper cards when visible class is present (regardless of expanded state) */
      .SearchHelperCards-module__helperCardsContainer.SearchHelperCards-module__visible {
        display: flex !important;
        visibility: visible !important;
        height: auto !important;
        overflow: visible !important;
        opacity: 1 !important;
        pointer-events: none !important;
        width: 100% !important;
        max-width: 100% !important;
      }
      /* Also show in expanded state */
      .SearchBar-module__searchBar.SearchBar-module__expanded .SearchHelperCards-module__helperCardsContainer {
        display: flex !important;
        visibility: visible !important;
        height: auto !important;
        overflow: visible !important;
        opacity: 1 !important;
        pointer-events: none !important;
        width: 100% !important;
        max-width: 100% !important;
      }
      /* Expanded SearchBar width */
      .SearchBar-module__searchBar.SearchBar-module__expanded {
        max-width: 636px !important;
      }
      /* Expanded SearchBar input text size */
      .SearchBar-module__searchBar.SearchBar-module__expanded .SearchBar-module__searchInput,
      .SearchBar-module__searchBar.SearchBar-module__expanded input {
        font-size: 20px !important;
      }
      .SearchBar-module__searchBar.SearchBar-module__expanded input::placeholder {
        font-size: 20px !important;
      }
      /* Helper cards themselves are clickable */
      .SearchHelperCard-module__helperCard {
        pointer-events: auto !important;
      }
      /* Helper cards inner container matches SearchBar width */
      .SearchHelperCards-module__helperCards {
        width: 100% !important;
        max-width: 100% !important;
      }
      /* Icon - 24px size, no extra padding */
      .SearchBar-module__searchBar.SearchBar-module__collapsed .SearchBar-module__searchIconContainer {
        flex-shrink: 0 !important;
        width: 24px !important;
        height: 24px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        padding: 0 !important;
        margin: 0 !important;
      }
      .SearchBar-module__searchBar.SearchBar-module__collapsed .Icon-module__icon,
      .SearchBar-module__searchBar.SearchBar-module__collapsed .SearchBar-module__searchIcon {
        flex-shrink: 0 !important;
        width: 24px !important;
        height: 24px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        padding: 0 !important;
        margin: 0 !important;
      }
      .SearchBar-module__searchBar.SearchBar-module__collapsed .Icon-module__icon svg,
      .SearchBar-module__searchBar.SearchBar-module__collapsed .SearchBar-module__searchIcon svg {
        width: 24px !important;
        height: 24px !important;
      }
      /* Input - flex to fill remaining space */
      .SearchBar-module__searchBar.SearchBar-module__collapsed .SearchBar-module__searchInput,
      .SearchBar-module__searchBar.SearchBar-module__collapsed input {
        flex: 1 1 auto !important;
        min-width: 0 !important;
        color: #62625B !important;
        font-size: 20px !important;
        font-weight: 400 !important;
        font-family: "Pin Sans", -apple-system, "system-ui", "Segoe UI", sans-serif !important;
        background: transparent !important;
        border: none !important;
        outline: none !important;
        padding: 0 !important;
        margin: 0 !important;
      }
      .SearchBar-module__searchBar.SearchBar-module__collapsed input::placeholder {
        color: #62625B !important;
        font-size: 20px !important;
        font-weight: 400 !important;
        font-family: "Pin Sans", -apple-system, "system-ui", "Segoe UI", sans-serif !important;
      }
      /* Input row container - matches computed styles */
      .SearchBar-module__searchBar.SearchBar-module__collapsed .SearchBar-module__inputRow {
        display: flex !important;
        align-items: center !important;
        column-gap: 12px !important;
        row-gap: 12px !important;
        width: auto !important;
        flex: 0 0 auto !important;
        padding: 0 !important;
        margin: 0 !important;
      }
      
      /* Typing Search Card - single card shown while typing */
      .search-typing-card {
        display: flex !important;
        align-items: center !important;
        gap: 12px !important;
        box-sizing: border-box !important;
        width: 100% !important;
        max-width: 100% !important;
        min-width: 100% !important;
        flex: 1 1 100% !important;
        height: 80px !important;
        padding: 4px 16px !important;
        background-color: rgb(255, 255, 255) !important;
        border-radius: 14px !important;
        border: none !important;
        box-shadow: rgba(0, 0, 0, 0.1) 0px 10px 15px -3px, rgba(0, 0, 0, 0.1) 0px 4px 6px -4px !important;
        pointer-events: auto !important;
        animation: SearchHelperCard-module__slideIn 0.2s cubic-bezier(0.34, 1.56, 0.64, 1) backwards !important;
      }
      .search-typing-card__icon {
        width: 20px !important;
        height: 20px !important;
        flex-shrink: 0 !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
      }
      .search-typing-card__icon svg {
        width: 20px !important;
        height: 20px !important;
      }
      /* Ensure container stretches to match SearchBar width when in typing mode */
      .SearchHelperCards-module__helperCardsContainer.typing-mode {
        width: 100% !important;
        max-width: 100% !important;
      }
      .SearchHelperCards-module__helperCardsContainer.typing-mode .SearchHelperCards-module__helperCards {
        width: 100% !important;
        max-width: 100% !important;
        display: flex !important;
        flex-direction: column !important;
      }
      .search-typing-card__title {
        font-family: "Pin Sans", -apple-system, "system-ui", "Segoe UI", sans-serif !important;
        font-size: 16px !important;
        font-weight: 400 !important;
        line-height: 1.4 !important;
        text-align: left !important;
        color: #767676 !important;
        -webkit-font-smoothing: antialiased !important;
        margin: 0 !important;
      }
      /* Hide original helper cards when typing card is visible */
      .SearchHelperCards-module__helperCardsContainer.typing-mode .SearchHelperCard-module__helperCard:not(.search-typing-card) {
        display: none !important;
      }
      
      /* Avatar Menu Overlay */
      .avatar-menu-overlay {
        position: fixed;
        width: 280px;
        height: 308px;
        background-color: #FFFFFF;
        border-radius: 12px;
        box-shadow: 0 1.5px 6px rgba(0, 0, 0, 0.2);
        z-index: 10000;
        display: none;
        flex-direction: column;
        font-family: "Pin Sans", -apple-system, "system-ui", "Segoe UI", sans-serif;
        overflow: hidden;
      }
      .avatar-menu-overlay.visible {
        display: flex;
      }
      .avatar-menu-overlay__section {
        padding: 16px;
      }
      .avatar-menu-overlay__section-header {
        font-size: 12px;
        font-weight: 400;
        color: #767676;
        margin-bottom: 12px;
      }
      .avatar-menu-overlay__current-account {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .avatar-menu-overlay__account-avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        object-fit: cover;
      }
      .avatar-menu-overlay__account-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .avatar-menu-overlay__account-name {
        font-size: 16px;
        font-weight: 600;
        color: #111111;
      }
      .avatar-menu-overlay__account-type {
        font-size: 14px;
        font-weight: 400;
        color: #767676;
      }
      .avatar-menu-overlay__checkmark {
        width: 24px;
        height: 24px;
        color: #111111;
      }
      .avatar-menu-overlay__menu-item {
        padding: 12px 16px;
        font-size: 16px;
        font-weight: 600;
        color: #111111;
        cursor: pointer;
        transition: background-color 0.15s ease;
      }
      .avatar-menu-overlay__menu-item:hover {
        background-color: #F0F0F0;
      }
      .avatar-menu-overlay__divider {
        height: 1px;
        background-color: #EFEFEF;
        margin: 0;
      }
      </style>
    </head>

  <body>
    <div id="root"></div>
    <script>
      // Fix image paths for GitHub Pages
      (function() {
        const basePath = '/dweb-rh';
        const maxImageNumber = 21; // We only have hf-1.jpg through hf-21.jpg
        
        // Map missing image numbers to existing ones and fix extensions
        function getValidImagePath(requestedPath) {
          if (!requestedPath) return null;
          // Extract image number from path like /dweb-rh/assets/images/hf-40.jpg or hf-40.jpg
          const match = requestedPath.match(/hf-(\d+)\.(jpg|webp|png)/i);
          if (match) {
            const requestedNum = parseInt(match[1], 10);
            const originalExtension = match[2].toLowerCase();
            
            // Always map to .jpg since we only have .jpg files (except hf-2.webp)
            const validNum = requestedNum > maxImageNumber 
              ? ((requestedNum - 1) % maxImageNumber) + 1 
              : requestedNum;
            
            // Always convert to .jpg (we only have .jpg files, not .png or .webp except hf-2.webp)
            // But we'll use .jpg for consistency
            let fixedPath = requestedPath.replace(/hf-\d+\.(jpg|webp|png)/i, `hf-${validNum}.jpg`);
            
            // If the number changed OR the extension changed, log it
            if (fixedPath !== requestedPath) {
              console.log('Fixed image path:', requestedPath, '->', fixedPath, 
                (requestedNum > maxImageNumber ? '(number mapped)' : ''), 
                (originalExtension !== 'jpg' ? '(extension converted)' : ''));
            }
            return fixedPath;
          }
          return null;
        }
        
        // Helper to fix path and image number in one go
        function fixPathAndImageNumber(path) {
          if (!path || typeof path !== 'string') return path;
          
          // First fix the base path
          let fixedPath = path;
          try {
            const url = new URL(path, window.location.origin);
            fixedPath = url.pathname;
          } catch(e) {
            if (path.startsWith('/')) {
              fixedPath = path;
            }
          }
          
          // Fix base path if needed
          if (fixedPath && fixedPath.startsWith('/assets/') && !fixedPath.startsWith(basePath)) {
            fixedPath = basePath + fixedPath;
          }
          
          // Always check for image number and extension fixes (even for valid numbers, need to fix .png -> .jpg)
          const validPath = getValidImagePath(fixedPath);
          if (validPath) {
            fixedPath = validPath;
          }
          
          return fixedPath;
        }
        
        function fixImageSrc(img) {
          if (!img) return;
          // Check src, data-src, and other lazy loading attributes
          let src = img.getAttribute('src') || 
                    img.getAttribute('data-src') || 
                    img.getAttribute('data-lazy-src') ||
                    img.src || '';
          
          const originalSrc = src;
          
          // Remove domain if present to get just the path
          try {
            const url = new URL(src, window.location.origin);
            src = url.pathname;
          } catch(e) {
            // Not a full URL, use as is
            if (src && !src.startsWith('/') && !src.startsWith('http')) {
              // Relative path, skip
              return false;
            }
          }
          
          // Check if it needs fixing
          if (src && src.startsWith('/assets/') && !src.startsWith(basePath)) {
            const fixedSrc = basePath + src;
            // Fix all possible attributes
            if (img.getAttribute('src')) img.setAttribute('src', fixedSrc);
            if (img.getAttribute('data-src')) img.setAttribute('data-src', fixedSrc);
            if (img.getAttribute('data-lazy-src')) img.setAttribute('data-lazy-src', fixedSrc);
            img.src = fixedSrc;
            console.log('Fixed image path:', originalSrc, '->', fixedSrc);
            return true;
          }
          
          // Log images that might need fixing but don't match our pattern
          if (src && src.includes('assets') && !src.startsWith(basePath)) {
            console.warn('Image with assets path not fixed:', src, img);
          }
          
          return false;
        }
        
        // Override src property setter on HTMLImageElement prototype - more aggressive
        const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
        if (originalSrcDescriptor && originalSrcDescriptor.set) {
          const originalSet = originalSrcDescriptor.set;
          Object.defineProperty(HTMLImageElement.prototype, 'src', {
            set: function(value) {
              if (value && typeof value === 'string') {
                let path = value;
                try {
                  const url = new URL(value, window.location.origin);
                  path = url.pathname;
                } catch(e) {
                  // Not a full URL, check if it's a relative path
                  if (value.startsWith('/')) {
                    path = value;
                  }
                }
                // Fix both path and image number
                const fixedPath = fixPathAndImageNumber(value);
                if (fixedPath !== value) {
                  console.log('Fixed src setter:', value, '->', fixedPath);
                  value = fixedPath;
                }
              }
              originalSet.call(this, value);
            },
            get: originalSrcDescriptor.get,
            configurable: true,
            enumerable: true
          });
        }
        
        // Also override data-src and other lazy loading attributes
        const originalSetAttribute = Element.prototype.setAttribute;
        Element.prototype.setAttribute = function(name, value) {
          if (this.tagName === 'IMG' && (name === 'src' || name === 'data-src' || name === 'data-lazy-src')) {
            if (value && typeof value === 'string') {
              let path = value;
              try {
                const url = new URL(value, window.location.origin);
                path = url.pathname;
              } catch(e) {
                if (value.startsWith('/')) {
                  path = value;
                }
              }
              // Fix both path and image number
              const fixedPath = fixPathAndImageNumber(value);
              if (fixedPath !== value) {
                console.log('Fixed setAttribute:', name, value, '->', fixedPath);
                value = fixedPath;
              }
            }
          }
          return originalSetAttribute.call(this, name, value);
        };
        
        // Intercept image error events and map missing images to existing ones
        document.addEventListener('error', function(e) {
          if (e.target && e.target.tagName === 'IMG') {
            const img = e.target;
            let src = img.src || img.getAttribute('src') || img.getAttribute('data-src') || '';
            
            // Remove domain to get just path
            try {
              const url = new URL(src, window.location.origin);
              src = url.pathname;
            } catch(e) {}
            
            console.error('Image failed to load:', src, img);
            
            // Try to map to a valid image
            let fixedPath = fixPathAndImageNumber(src);
            
            // If it's still hf-2.jpg or hf-10.jpg and failed, try a different image
            if (fixedPath && (fixedPath.includes('/hf-2.jpg') || fixedPath.includes('/hf-10.jpg'))) {
              // Try using a random valid image instead
              const randomNum = Math.floor(Math.random() * maxImageNumber) + 1;
              fixedPath = fixedPath.replace(/hf-\d+\.jpg/i, `hf-${randomNum}.jpg`);
              console.log('Retrying with random image:', src, '->', fixedPath);
            }
            
            if (fixedPath && fixedPath !== src) {
              img.src = fixedPath;
              if (img.getAttribute('src')) img.setAttribute('src', fixedPath);
              if (img.getAttribute('data-src')) img.setAttribute('data-src', fixedPath);
              console.log('Fixed missing image by mapping to valid image:', src, '->', fixedPath);
            } else {
              // Try to fix path one more time
              if (src && src.includes('/assets/')) {
                setTimeout(() => fixImageSrc(img), 0);
              }
            }
          }
        }, true);
        
        // Also proactively fix images that request numbers > 21
        function fixImageNumber(img) {
          if (!img) return;
          let src = img.getAttribute('src') || img.getAttribute('data-src') || img.src || '';
          const fixedPath = fixPathAndImageNumber(src);
          if (fixedPath && fixedPath !== src) {
            img.src = fixedPath;
            if (img.getAttribute('src')) img.setAttribute('src', fixedPath);
            if (img.getAttribute('data-src')) img.setAttribute('data-src', fixedPath);
            console.log('Fixed image number:', src, '->', fixedPath);
            return true;
          }
          return false;
        }
        
        // Fix images that are already in the DOM
        function fixImagePaths() {
          const images = document.querySelectorAll('img');
          images.forEach(img => {
            // Try multiple times with different approaches
            fixImageSrc(img);
            fixImageNumber(img);
            
            // Also check current src and fix if needed
            const currentSrc = img.src || img.getAttribute('src') || img.getAttribute('data-src');
            if (currentSrc) {
              const fixed = fixPathAndImageNumber(currentSrc);
              if (fixed && fixed !== currentSrc) {
                img.src = fixed;
                if (img.getAttribute('src')) img.setAttribute('src', fixed);
                if (img.getAttribute('data-src')) img.setAttribute('data-src', fixed);
              }
            }
          });
        }
        
        // Override Image constructor to fix dynamically created images
        const OriginalImage = window.Image;
        window.Image = function(...args) {
          const img = new OriginalImage(...args);
          if (args.length > 0 && typeof args[0] === 'string') {
            const src = args[0];
            if (src.startsWith('/assets/') && !src.startsWith(basePath)) {
              img.src = basePath + src;
            }
          }
          return img;
        };
        
        // Watch for new images being added - more aggressive
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.nodeType === 1) { // Element node
                if (node.tagName === 'IMG') {
                  fixImageSrc(node);
                  // Also check for data-src that might be converted later
                  setTimeout(() => fixImageSrc(node), 0);
                  setTimeout(() => fixImageSrc(node), 50);
                  setTimeout(() => fixImageSrc(node), 100);
                }
                // Check child images
                const images = node.querySelectorAll && node.querySelectorAll('img');
                if (images) {
                  images.forEach(img => {
                    fixImageSrc(img);
                    setTimeout(() => fixImageSrc(img), 0);
                    setTimeout(() => fixImageSrc(img), 50);
                    setTimeout(() => fixImageSrc(img), 100);
                  });
                }
              }
            });
          });
        });
        
        // Fix existing images
        fixImagePaths();
        
        // Watch for new images
        observer.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['src']
        });
        
        // Also fix images on attribute changes - watch for src, data-src, etc.
        const attrObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            const attrName = mutation.attributeName;
            if (mutation.type === 'attributes' && 
                (attrName === 'src' || attrName === 'data-src' || attrName === 'data-lazy-src')) {
              fixImageSrc(mutation.target);
            }
          });
        });
        
        // Watch for src attribute changes on all images - including data-src
        function observeAllImages() {
          const allImages = document.querySelectorAll('img');
          allImages.forEach(img => {
            attrObserver.observe(img, { 
              attributes: true, 
              attributeFilter: ['src', 'data-src', 'data-lazy-src'] 
            });
            fixImageSrc(img);
          });
        }
        
        document.addEventListener('DOMContentLoaded', observeAllImages);
        
        // Periodic check to catch images that might be missed (more frequent)
        setInterval(function() {
          fixImagePaths();
        }, 300);
        
        // Also check after delays to catch React-rendered images
        setTimeout(fixImagePaths, 50);
        setTimeout(fixImagePaths, 100);
        setTimeout(fixImagePaths, 200);
        setTimeout(fixImagePaths, 300);
        setTimeout(fixImagePaths, 500);
        setTimeout(fixImagePaths, 750);
        setTimeout(fixImagePaths, 1000);
        setTimeout(fixImagePaths, 1500);
        setTimeout(fixImagePaths, 2000);
        setTimeout(fixImagePaths, 3000);
        setTimeout(fixImagePaths, 4000);
        setTimeout(fixImagePaths, 5000);
        
        // Watch for scroll events (lazy loading) - more aggressive
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          clearTimeout(scrollTimeout);
          // Fix immediately and also after a short delay
          fixImagePaths();
          scrollTimeout = setTimeout(fixImagePaths, 50);
          setTimeout(fixImagePaths, 150);
          setTimeout(fixImagePaths, 300);
        }, { passive: true });
        
        // Also watch for resize events (might trigger lazy loading)
        window.addEventListener('resize', function() {
          setTimeout(fixImagePaths, 100);
        }, { passive: true });
        
        // Watch for intersection observer (common for lazy loading)
        const originalIntersectionObserver = window.IntersectionObserver;
        window.IntersectionObserver = function(callback, options) {
          const wrappedCallback = function(entries, observer) {
            // Fix images before and after callback runs
            fixImagePaths();
            setTimeout(fixImagePaths, 0);
            setTimeout(fixImagePaths, 50);
            setTimeout(fixImagePaths, 100);
            const result = callback(entries, observer);
            setTimeout(fixImagePaths, 0);
            return result;
          };
          return new originalIntersectionObserver(wrappedCallback, options);
        };
        
        // Also intercept requestAnimationFrame (React might use this)
        const originalRAF = window.requestAnimationFrame;
        window.requestAnimationFrame = function(callback) {
          return originalRAF(function(time) {
            const result = callback(time);
            // Check images after animation frame
            setTimeout(fixImagePaths, 0);
            return result;
          });
        };
      })();
      
      // Make boards icon clickable - wait for React app to render
      (function() {
        let boardsIcon = null;
        let attempts = 0;
        const maxAttempts = 50; // Try for 5 seconds
        
        function findBoardsIcon() {
          // Look for nav element
          const nav = document.querySelector('[class*="GlobalNav"]') || 
                     document.querySelector('nav') ||
                     document.querySelector('[class*="globalNav"]');
          
          if (!nav) return null;
          
          // Get all clickable elements in nav
          const clickables = nav.querySelectorAll('button, [role="button"], a, div[class*="iconButton"], div[class*="IconButton"]');
          
          for (let el of clickables) {
            // Check text content
            const text = (el.textContent || el.innerText || '').trim();
            const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();
            const title = (el.getAttribute('title') || '').toLowerCase();
            
            // Check if this is the boards icon
            if (text === 'Boards' || ariaLabel.includes('boards') || title.includes('boards')) {
              return el;
            }
            
            // Check parent element
            const parent = el.parentElement;
            if (parent) {
              const parentText = (parent.textContent || parent.innerText || '').trim();
              if (parentText === 'Boards') {
                return parent;
              }
            }
          }
          
          // Alternative: look for icon by position (4th icon in leading section)
          const leading = nav.querySelector('[class*="leading"]') || nav.querySelector('[class*="Leading"]');
          if (leading) {
            const icons = leading.querySelectorAll('button, [role="button"], a, div[class*="iconButton"], div[class*="IconButton"]');
            // Boards is typically the 4th icon (index 3: Pinterest, Home, Explore, Boards)
            if (icons.length >= 4) {
              return icons[3];
            }
          }
          
          return null;
        }
        
        function attachClickHandler() {
          if (boardsIcon) return; // Already attached
          
          boardsIcon = findBoardsIcon();
          
          if (boardsIcon) {
            boardsIcon.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              window.location.href = '/dweb-rh/boards.html';
              return false;
            });
            boardsIcon.style.cursor = 'pointer';
            console.log('Boards icon click handler attached');
            return true;
          }
          
          return false;
        }
        
        // Try immediately
        if (!attachClickHandler()) {
          // Use MutationObserver to watch for DOM changes
          const observer = new MutationObserver(function() {
            attempts++;
            if (attachClickHandler() || attempts >= maxAttempts) {
              observer.disconnect();
            }
          });
          
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
          
          // Also try on intervals as fallback
          const interval = setInterval(function() {
            attempts++;
            if (attachClickHandler() || attempts >= maxAttempts) {
              clearInterval(interval);
              observer.disconnect();
            }
          }, 100);
        }
      })();
      
      // ScrollableSearchBar scroll behavior with 1-second debounced show
      // Hides immediately on scroll down, shows only after 1 second of no scrolling
      (function() {
        console.log('[ScrollBehavior] Script starting...');
        let lastScrollTop = 0;
        const scrollThreshold = 50;
        let searchBarWrapper = null;
        let scrollContainer = null;
        let scrollHandlerInitialized = false;
        
        // Debounce timeout for showing the SearchBar (1 second delay)
        let scrollShowTimeout = null;
        
        function findElements() {
          searchBarWrapper = document.querySelector('.ScrollableSearchBar-module__searchBarWrapper');
          // Find the actual scroll container - likely a main content area
          scrollContainer = document.querySelector('.HomePage-module__homePage') ||
                           document.querySelector('[class*="homePage"]') ||
                           document.querySelector('main') ||
                           document.documentElement;
          if (searchBarWrapper) {
            console.log('[ScrollBehavior] Found wrapper:', searchBarWrapper.className);
            console.log('[ScrollBehavior] Scroll container:', scrollContainer ? scrollContainer.className || scrollContainer.tagName : 'none');
          }
          return searchBarWrapper !== null;
        }
        
        // Hide SearchBar IMMEDIATELY - use React's class mechanism
        function hideSearchBar() {
          if (!searchBarWrapper) return;
          console.log('[ScrollBehavior] HIDE');
          // Clear any pending show timeout - user is still scrolling
          clearTimeout(scrollShowTimeout);
          scrollShowTimeout = null;
          // Use React's class + our attribute for CSS
          searchBarWrapper.classList.remove('ScrollableSearchBar-module__visible');
          searchBarWrapper.classList.add('ScrollableSearchBar-module__hidden');
          searchBarWrapper.setAttribute('data-scroll-collapsed', 'true');
        }
        
        // Show SearchBar in COLLAPSED state - called after scroll pause
        function showSearchBarCollapsed() {
          if (!searchBarWrapper) return;
          console.log('[ScrollBehavior] SHOW (collapsed)');
          // Show wrapper
          searchBarWrapper.classList.remove('ScrollableSearchBar-module__hidden');
          searchBarWrapper.classList.add('ScrollableSearchBar-module__visible');
          searchBarWrapper.removeAttribute('data-scroll-collapsed');
          
          // Set SearchBar to collapsed state (smaller input, chips stay visible)
          const searchBar = searchBarWrapper.querySelector('.SearchBar-module__searchBar');
          if (searchBar) {
            searchBar.classList.remove('SearchBar-module__expanded');
            searchBar.classList.add('SearchBar-module__collapsed');
          }
        }
        
        // Show SearchBar in EXPANDED state - called at top of page
        function showSearchBarExpanded() {
          if (!searchBarWrapper) return;
          console.log('[ScrollBehavior] SHOW (expanded)');
          // Show wrapper
          searchBarWrapper.classList.remove('ScrollableSearchBar-module__hidden');
          searchBarWrapper.classList.add('ScrollableSearchBar-module__visible');
          searchBarWrapper.removeAttribute('data-scroll-collapsed');
          
          // Set SearchBar to expanded state
          const searchBar = searchBarWrapper.querySelector('.SearchBar-module__searchBar');
          if (searchBar) {
            searchBar.classList.remove('SearchBar-module__collapsed');
            searchBar.classList.add('SearchBar-module__expanded');
          }
        }
        
        // Schedule showing the SearchBar in COLLAPSED state after 0.5 seconds of no scrolling
        function scheduleShowSearchBar() {
          console.log('[ScrollBehavior] Scheduling show (collapsed) in 0.5 seconds...');
          clearTimeout(scrollShowTimeout);
          scrollShowTimeout = setTimeout(function() {
            console.log('[ScrollBehavior] 0.5 seconds passed - showing collapsed');
            showSearchBarCollapsed();
          }, 500);
        }
        
        function getScrollTop() {
          // Try multiple sources for scroll position
          if (scrollContainer && scrollContainer !== document.documentElement) {
            return scrollContainer.scrollTop;
          }
          return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        }
        
        function handleScroll() {
          if (!findElements()) return;
          
          const scrollTop = getScrollTop();
          const scrollDelta = scrollTop - lastScrollTop;
          const isScrolling = scrollDelta !== 0;
          const atTop = scrollTop <= scrollThreshold;
          const searchBar = searchBarWrapper.querySelector('.SearchBar-module__searchBar');
          const isExpanded = searchBar && searchBar.classList.contains('SearchBar-module__expanded');
          
          console.log('[ScrollBehavior] handleScroll - scrollTop:', scrollTop, 'delta:', scrollDelta, 'atTop:', atTop, 'isExpanded:', isExpanded);
          
          // Clear any pending timeout on every scroll event
          clearTimeout(scrollShowTimeout);
          scrollShowTimeout = null;
          
          // At top of page - show at 100% expanded
          if (atTop) {
            console.log('[ScrollBehavior] At top - showing expanded');
            showSearchBarExpanded();
          }
          // Any scrolling (up or down) when not at top - hide SearchBar (50% opacity)
          else if (isScrolling) {
            console.log('[ScrollBehavior] Scrolling (not at top) - hiding');
            hideSearchBar();
            
            // Schedule show after 0.5s pause
            scrollShowTimeout = setTimeout(function() {
              const currentScrollTop = getScrollTop();
              const currentAtTop = currentScrollTop <= scrollThreshold;
              
              if (currentAtTop) {
                console.log('[ScrollBehavior] 0.5s passed, at top - showing expanded');
                showSearchBarExpanded();
              } else {
                console.log('[ScrollBehavior] 0.5s passed, not at top - showing collapsed');
                showSearchBarCollapsed();
              }
            }, 500);
          }
          
          lastScrollTop = scrollTop;
        }
        
        function onScroll() {
          window.requestAnimationFrame(handleScroll);
        }
        
        function initScrollListener() {
          if (findElements() && !scrollHandlerInitialized) {
            lastScrollTop = getScrollTop();
            
            // Listen on window (captures bubbled events)
            window.addEventListener('scroll', onScroll, { passive: true, capture: true });
            
            // Also listen on the scroll container if different from window
            if (scrollContainer && scrollContainer !== document.documentElement) {
              scrollContainer.addEventListener('scroll', onScroll, { passive: true });
              console.log('[ScrollBehavior] Added listener to scroll container');
            }
            
            // Listen on document for any scroll
            document.addEventListener('scroll', onScroll, { passive: true, capture: true });
            
            // Add click handler for collapsed SearchBar - expand on click
            const searchBar = searchBarWrapper.querySelector('.SearchBar-module__searchBar');
            if (searchBar) {
              searchBar.addEventListener('click', function(e) {
                // Only expand if currently collapsed
                if (searchBar.classList.contains('SearchBar-module__collapsed')) {
                  console.log('[ScrollBehavior] Collapsed SearchBar clicked - expanding');
                  showSearchBarExpanded();
                  // Focus the input
                  const input = searchBar.querySelector('input');
                  if (input) {
                    setTimeout(function() { input.focus(); }, 50);
                  }
                }
              });
              console.log('[ScrollBehavior] ✓ Click handler added for collapsed SearchBar');
            }
            
            // Ensure scrolling stays enabled - MutationObserver to remove overflow:hidden
            function forceEnableScroll() {
              const elements = [document.body, document.documentElement, document.getElementById('root')];
              elements.forEach(function(el) {
                if (el && el.style) {
                  if (el.style.overflow === 'hidden') el.style.overflow = 'auto';
                  if (el.style.overflowY === 'hidden') el.style.overflowY = 'auto';
                  if (el.style.position === 'fixed') el.style.position = 'static';
                  if (el.style.height === '100%' || el.style.height === '100vh') el.style.height = 'auto';
                }
              });
            }
            const scrollEnforcer = new MutationObserver(forceEnableScroll);
            scrollEnforcer.observe(document.body, { attributes: true, attributeFilter: ['style', 'class'] });
            scrollEnforcer.observe(document.documentElement, { attributes: true, attributeFilter: ['style', 'class'] });
            const rootEl = document.getElementById('root');
            if (rootEl) {
              scrollEnforcer.observe(rootEl, { attributes: true, attributeFilter: ['style', 'class'] });
            }
            // Also run periodically as fallback
            setInterval(forceEnableScroll, 500);
            console.log('[ScrollBehavior] ✓ Scroll enforcer MutationObserver initialized');
            
            scrollHandlerInitialized = true;
            console.log('[ScrollBehavior] ✓ Scroll listeners initialized! lastScrollTop:', lastScrollTop);
            return true;
          }
          return false;
        }
        
        // Wait for React to render
        let attempts = 0;
        const maxAttempts = 100;
        const checkInterval = setInterval(function() {
          attempts++;
          if (initScrollListener() || attempts >= maxAttempts) {
            clearInterval(checkInterval);
          }
        }, 100);
        
        const observer = new MutationObserver(function() {
          if (findElements() && !scrollHandlerInitialized) {
            initScrollListener();
          }
        });
        observer.observe(document.body, { childList: true, subtree: true });
      })();
      
      // Avatar Menu Overlay
      (function() {
        console.log('[AvatarMenu] Script starting...');
        let avatarMenu = null;
        let avatarButton = null;
        let isMenuOpen = false;
        
        function createAvatarMenu() {
          if (avatarMenu) return avatarMenu;
          
          avatarMenu = document.createElement('div');
          avatarMenu.className = 'avatar-menu-overlay';
          avatarMenu.innerHTML = `
            <div class="avatar-menu-overlay__section">
              <div class="avatar-menu-overlay__section-header">Currently in</div>
              <div class="avatar-menu-overlay__current-account">
                <img class="avatar-menu-overlay__account-avatar" src="/dweb-rh/assets/avatar/avatar.png" alt="Profile" />
                <div class="avatar-menu-overlay__account-info">
                  <span class="avatar-menu-overlay__account-name">kim</span>
                  <span class="avatar-menu-overlay__account-type">Personal</span>
                </div>
                <svg class="avatar-menu-overlay__checkmark" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
              </div>
            </div>
            <div class="avatar-menu-overlay__divider"></div>
            <div class="avatar-menu-overlay__menu-item">Visit profile</div>
            <div class="avatar-menu-overlay__menu-item">Convert to business</div>
            <div class="avatar-menu-overlay__divider"></div>
            <div class="avatar-menu-overlay__section">
              <div class="avatar-menu-overlay__section-header">Your accounts</div>
            </div>
            <div class="avatar-menu-overlay__menu-item">Add Pinterest account</div>
            <div class="avatar-menu-overlay__menu-item">Log out</div>
          `;
          
          document.body.appendChild(avatarMenu);
          console.log('[AvatarMenu] Menu element created');
          return avatarMenu;
        }
        
        function positionMenu() {
          if (!avatarMenu || !avatarButton) return;
          
          const globalNav = document.querySelector('[class*="GlobalNav-module__globalNav"]');
          const buttonRect = avatarButton.getBoundingClientRect();
          
          // Position: 8px to the right of GlobalNav, 40px above the top of AvatarButton
          let top = buttonRect.top - 40;
          let left = 8; // 8px from left edge of viewport (right of GlobalNav)
          
          // If GlobalNav exists, position relative to it
          if (globalNav) {
            const navRect = globalNav.getBoundingClientRect();
            left = navRect.right + 8; // 8px to the right of GlobalNav
            top = navRect.bottom + 8; // 8px below GlobalNav
          }
          
          avatarMenu.style.top = top + 'px';
          avatarMenu.style.left = left + 'px';
        }
        
        function showMenu() {
          if (!avatarMenu) createAvatarMenu();
          positionMenu();
          avatarMenu.classList.add('visible');
          isMenuOpen = true;
          console.log('[AvatarMenu] Menu shown');
        }
        
        function hideMenu() {
          if (avatarMenu) {
            avatarMenu.classList.remove('visible');
          }
          isMenuOpen = false;
          console.log('[AvatarMenu] Menu hidden');
        }
        
        function toggleMenu(e) {
          e.preventDefault();
          e.stopPropagation();
          
          if (isMenuOpen) {
            hideMenu();
          } else {
            showMenu();
          }
        }
        
        function handleOutsideClick(e) {
          if (!isMenuOpen) return;
          
          // Check if click is outside the menu and avatar button
          if (avatarMenu && !avatarMenu.contains(e.target) && 
              avatarButton && !avatarButton.contains(e.target)) {
            hideMenu();
          }
        }
        
        function initAvatarMenu() {
          // Try multiple selectors
          avatarButton = document.querySelector('[class*="AvatarButton-module__avatarButton"]') ||
                         document.querySelector('[class*="avatarButton"]') ||
                         document.querySelector('.AvatarButton-module__avatarButton');
          
          if (avatarButton) {
            console.log('[AvatarMenu] Found avatar button:', avatarButton.className);
            // Use capturing phase to ensure our handler runs first
            avatarButton.addEventListener('click', toggleMenu, { capture: true });
            document.addEventListener('click', handleOutsideClick);
            console.log('[AvatarMenu] ✓ Avatar button click handler attached');
            return true;
          } else {
            // Log what elements exist in the nav for debugging
            const nav = document.querySelector('[class*="GlobalNav"]');
            if (nav) {
              const buttons = nav.querySelectorAll('button, [role="button"], div[class*="avatar"], img[class*="avatar"]');
              console.log('[AvatarMenu] Found potential buttons in nav:', buttons.length);
              buttons.forEach((b, i) => console.log('[AvatarMenu] Button', i, ':', b.className || b.tagName));
            }
          }
          return false;
        }
        
        // Wait for React to render
        let attempts = 0;
        const maxAttempts = 100;
        const checkInterval = setInterval(function() {
          attempts++;
          if (initAvatarMenu() || attempts >= maxAttempts) {
            if (attempts >= maxAttempts) {
              console.log('[AvatarMenu] Max attempts reached, button not found');
            }
            clearInterval(checkInterval);
          }
        }, 100);
        
        // Also use MutationObserver
        const observer = new MutationObserver(function() {
          if (!avatarButton) {
            initAvatarMenu();
          }
        });
        observer.observe(document.body, { childList: true, subtree: true });
      })();
      
      // Typing Search Card - show single card while typing in expanded SearchBar
      (function() {
        console.log('[TypingCard] Script starting...');
        let typingCard = null;
        let searchInput = null;
        let helperCardsContainer = null;
        let isTypingMode = false;
        
        function createTypingCard(query) {
          if (!typingCard) {
            typingCard = document.createElement('div');
            typingCard.className = 'search-typing-card';
            typingCard.innerHTML = `
              <span class="search-typing-card__icon">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path fill-rule="evenodd" clip-rule="evenodd" d="M17.3287 18.7429C15.6049 20.1536 13.4013 21 11 21C5.47715 21 1 16.5228 1 11C1 5.47715 5.47715 1 11 1C16.5228 1 21 5.47715 21 11C21 13.4013 20.1536 15.6049 18.7429 17.3287L23.2117 21.7975L21.7975 23.2117L17.3287 18.7429ZM19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z" fill="#74746C"/>
                </svg>
              </span>
              <span class="search-typing-card__title"></span>
            `;
          }
          
          // Update title with current query
          const titleEl = typingCard.querySelector('.search-typing-card__title');
          if (titleEl) {
            titleEl.textContent = query;
          }
          
          return typingCard;
        }
        
        function showTypingCard(query) {
          helperCardsContainer = document.querySelector('.SearchHelperCards-module__helperCardsContainer');
          if (!helperCardsContainer) return;
          
          // Add typing mode class to hide original cards
          helperCardsContainer.classList.add('typing-mode');
          
          // Create or update the typing card
          const card = createTypingCard(query);
          
          // Add to container if not already there
          if (!helperCardsContainer.contains(card)) {
            helperCardsContainer.appendChild(card);
          }
          
          isTypingMode = true;
          console.log('[TypingCard] Showing typing card with query:', query);
        }
        
        function hideTypingCard() {
          helperCardsContainer = document.querySelector('.SearchHelperCards-module__helperCardsContainer');
          if (!helperCardsContainer) return;
          
          // Remove typing mode class to show original cards
          helperCardsContainer.classList.remove('typing-mode');
          
          // Remove the typing card
          if (typingCard && helperCardsContainer.contains(typingCard)) {
            helperCardsContainer.removeChild(typingCard);
          }
          
          isTypingMode = false;
          console.log('[TypingCard] Hiding typing card, restoring original cards');
        }
        
        function handleInput(e) {
          const query = e.target.value.trim();
          
          // Check if SearchBar is expanded
          const searchBar = document.querySelector('.SearchBar-module__searchBar');
          const isExpanded = searchBar && searchBar.classList.contains('SearchBar-module__expanded');
          
          if (!isExpanded) return;
          
          if (query.length > 0) {
            showTypingCard(query);
          } else {
            hideTypingCard();
          }
        }
        
        function initTypingCard() {
          searchInput = document.querySelector('.SearchBar-module__searchBar input') ||
                       document.querySelector('.SearchBar-module__searchInput');
          
          if (searchInput && !searchInput.hasAttribute('data-typing-card-handler')) {
            searchInput.addEventListener('input', handleInput);
            searchInput.setAttribute('data-typing-card-handler', 'true');
            console.log('[TypingCard] ✓ Input handler attached');
            return true;
          }
          return false;
        }
        
        // Wait for React to render
        let attempts = 0;
        const maxAttempts = 100;
        const checkInterval = setInterval(function() {
          attempts++;
          if (initTypingCard() || attempts >= maxAttempts) {
            clearInterval(checkInterval);
          }
        }, 100);
        
        // Also use MutationObserver
        const observer = new MutationObserver(function() {
          if (!searchInput || !searchInput.hasAttribute('data-typing-card-handler')) {
            initTypingCard();
          }
        });
        observer.observe(document.body, { childList: true, subtree: true });
      })();
    </script>
  </body>
</html>
  