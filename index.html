
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Pinterest</title>
      <script type="module" crossorigin src="/dweb-rh/assets/index-BLL-NyY1.js"></script>
      <link rel="stylesheet" crossorigin href="/dweb-rh/assets/index-I0l3_rlN.css">
      <!-- Updated paths for GitHub Pages -->
    </head>

  <body>
    <div id="root"></div>
    <script>
      // Fix image paths for GitHub Pages
      (function() {
        const basePath = '/dweb-rh';
        
        function fixImageSrc(img) {
          if (!img) return;
          // Check both attribute and property
          let src = img.getAttribute('src') || img.src || '';
          // Remove domain if present to get just the path
          try {
            const url = new URL(src, window.location.origin);
            src = url.pathname;
          } catch(e) {
            // Not a full URL, use as is
          }
          
          if (src && src.startsWith('/assets/') && !src.startsWith(basePath)) {
            const fixedSrc = basePath + src;
            // Use Object.defineProperty to bypass our own setter temporarily
            const descriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
            if (descriptor && descriptor.set) {
              descriptor.set.call(img, fixedSrc);
            } else {
              img.src = fixedSrc;
            }
            img.setAttribute('src', fixedSrc);
            return true;
          }
          return false;
        }
        
        // Override src property setter on HTMLImageElement prototype
        const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
        if (originalSrcDescriptor && originalSrcDescriptor.set) {
          Object.defineProperty(HTMLImageElement.prototype, 'src', {
            set: function(value) {
              if (value && typeof value === 'string') {
                let path = value;
                try {
                  const url = new URL(value, window.location.origin);
                  path = url.pathname;
                } catch(e) {
                  // Not a full URL
                }
                if (path.startsWith('/assets/') && !path.startsWith(basePath)) {
                  value = basePath + path;
                }
              }
              originalSrcDescriptor.set.call(this, value);
            },
            get: originalSrcDescriptor.get,
            configurable: true,
            enumerable: true
          });
        }
        
        // Fix images that are already in the DOM
        function fixImagePaths() {
          const images = document.querySelectorAll('img');
          images.forEach(fixImageSrc);
        }
        
        // Override Image constructor to fix dynamically created images
        const OriginalImage = window.Image;
        window.Image = function(...args) {
          const img = new OriginalImage(...args);
          if (args.length > 0 && typeof args[0] === 'string') {
            const src = args[0];
            if (src.startsWith('/assets/') && !src.startsWith(basePath)) {
              img.src = basePath + src;
            }
          }
          return img;
        };
        
        // Watch for new images being added
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.nodeType === 1) { // Element node
                if (node.tagName === 'IMG') {
                  fixImageSrc(node);
                }
                // Check child images
                const images = node.querySelectorAll && node.querySelectorAll('img');
                if (images) {
                  images.forEach(fixImageSrc);
                }
              }
            });
          });
        });
        
        // Fix existing images
        fixImagePaths();
        
        // Watch for new images
        observer.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['src']
        });
        
        // Also fix images on attribute changes
        const attrObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'src') {
              fixImageSrc(mutation.target);
            }
          });
        });
        
        // Watch for src attribute changes on all images
        function observeAllImages() {
          const allImages = document.querySelectorAll('img');
          allImages.forEach(img => {
            attrObserver.observe(img, { attributes: true, attributeFilter: ['src'] });
            fixImageSrc(img);
          });
        }
        
        document.addEventListener('DOMContentLoaded', observeAllImages);
        
        // Periodic check to catch images that might be missed (more frequent)
        setInterval(function() {
          fixImagePaths();
        }, 500);
        
        // Also check after delays to catch React-rendered images
        setTimeout(fixImagePaths, 100);
        setTimeout(fixImagePaths, 300);
        setTimeout(fixImagePaths, 500);
        setTimeout(fixImagePaths, 1000);
        setTimeout(fixImagePaths, 2000);
        setTimeout(fixImagePaths, 3000);
        
        // Watch for scroll events (lazy loading)
        let scrollTimeout;
        window.addEventListener('scroll', function() {
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(fixImagePaths, 100);
        }, { passive: true });
        
        // Watch for intersection observer (common for lazy loading)
        const originalIntersectionObserver = window.IntersectionObserver;
        window.IntersectionObserver = function(callback, options) {
          const wrappedCallback = function(entries, observer) {
            // Fix images before callback runs
            setTimeout(fixImagePaths, 0);
            return callback(entries, observer);
          };
          return new originalIntersectionObserver(wrappedCallback, options);
        };
      })();
      
      // Make boards icon clickable - wait for React app to render
      (function() {
        let boardsIcon = null;
        let attempts = 0;
        const maxAttempts = 50; // Try for 5 seconds
        
        function findBoardsIcon() {
          // Look for nav element
          const nav = document.querySelector('[class*="GlobalNav"]') || 
                     document.querySelector('nav') ||
                     document.querySelector('[class*="globalNav"]');
          
          if (!nav) return null;
          
          // Get all clickable elements in nav
          const clickables = nav.querySelectorAll('button, [role="button"], a, div[class*="iconButton"], div[class*="IconButton"]');
          
          for (let el of clickables) {
            // Check text content
            const text = (el.textContent || el.innerText || '').trim();
            const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();
            const title = (el.getAttribute('title') || '').toLowerCase();
            
            // Check if this is the boards icon
            if (text === 'Boards' || ariaLabel.includes('boards') || title.includes('boards')) {
              return el;
            }
            
            // Check parent element
            const parent = el.parentElement;
            if (parent) {
              const parentText = (parent.textContent || parent.innerText || '').trim();
              if (parentText === 'Boards') {
                return parent;
              }
            }
          }
          
          // Alternative: look for icon by position (4th icon in leading section)
          const leading = nav.querySelector('[class*="leading"]') || nav.querySelector('[class*="Leading"]');
          if (leading) {
            const icons = leading.querySelectorAll('button, [role="button"], a, div[class*="iconButton"], div[class*="IconButton"]');
            // Boards is typically the 4th icon (index 3: Pinterest, Home, Explore, Boards)
            if (icons.length >= 4) {
              return icons[3];
            }
          }
          
          return null;
        }
        
        function attachClickHandler() {
          if (boardsIcon) return; // Already attached
          
          boardsIcon = findBoardsIcon();
          
          if (boardsIcon) {
            boardsIcon.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              window.location.href = '/dweb-rh/boards.html';
              return false;
            });
            boardsIcon.style.cursor = 'pointer';
            console.log('Boards icon click handler attached');
            return true;
          }
          
          return false;
        }
        
        // Try immediately
        if (!attachClickHandler()) {
          // Use MutationObserver to watch for DOM changes
          const observer = new MutationObserver(function() {
            attempts++;
            if (attachClickHandler() || attempts >= maxAttempts) {
              observer.disconnect();
            }
          });
          
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
          
          // Also try on intervals as fallback
          const interval = setInterval(function() {
            attempts++;
            if (attachClickHandler() || attempts >= maxAttempts) {
              clearInterval(interval);
              observer.disconnect();
            }
          }, 100);
        }
      })();
    </script>
  </body>
</html>
  