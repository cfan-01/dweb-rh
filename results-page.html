<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Results - Pinterest</title>
    <link rel="stylesheet" crossorigin href="/assets/index-I0l3_rlN.css">
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: var(--color-background);
        font-family: var(--font-family-pin-sans);
        display: flex;
        min-height: 100vh;
      }
      .app-container {
        display: flex;
        width: 100%;
        min-height: 100vh;
      }
      .App-module__main {
        display: none !important;
      }
      .SearchBar-module__searchBar.SearchBar-module__closeup[data-closeup-context-visible="true"] .SearchBar-module__searchIconContainer {
        width: 48px !important;
        height: 48px !important;
        transform: scale(1) !important;
        opacity: 1 !important;
        visibility: visible !important;
      }
      .SearchBar-module__searchInput {
        margin-left: 12px !important;
        pointer-events: auto !important;
        user-select: auto !important;
        cursor: text !important;
      }
      .SearchBar-module__searchInput[readonly],
      .SearchBar-module__searchInput[disabled] {
        pointer-events: auto !important;
        user-select: auto !important;
        cursor: text !important;
      }
      .IconButton-module__iconButton[aria-current="page"],
      .IconButton-module__iconButton[aria-selected="true"],
      .IconButton-module__iconButton.active,
      .IconButton-module__iconButton[data-active="true"] {
        background-color: #000000 !important;
        border-radius: 8px !important;
        padding: 8px 12px !important;
      }
      .IconButton-module__iconButton[aria-current="page"] svg,
      .IconButton-module__iconButton[aria-current="page"] svg path,
      .IconButton-module__iconButton[aria-selected="true"] svg,
      .IconButton-module__iconButton[aria-selected="true"] svg path,
      .IconButton-module__iconButton.active svg,
      .IconButton-module__iconButton.active svg path,
      .IconButton-module__iconButton[data-active="true"] svg,
      .IconButton-module__iconButton[data-active="true"] svg path {
        fill: #ffffff !important;
        color: #ffffff !important;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" crossorigin src="/assets/index-BLL-NyY1.js"></script>
    <script>
      // Fix App-module__app link to home page
      (function() {
        let attempts = 0;
        const maxAttempts = 50;
        
        function fixAppLink() {
          const appLink = document.querySelector('.App-module__app');
          if (appLink) {
            // If it's already an anchor tag, set href
            if (appLink.tagName === 'A') {
              appLink.href = '/index.html';
              appLink.setAttribute('href', '/index.html');
            } else {
              // If it's a button or div, make it clickable
              appLink.style.cursor = 'pointer';
              appLink.addEventListener('click', function(e) {
                e.preventDefault();
                window.location.href = '/index.html';
              });
            }
            return true;
          }
          return false;
        }
        
        if (!fixAppLink()) {
          const observer = new MutationObserver(function() {
            attempts++;
            if (fixAppLink() || attempts >= maxAttempts) {
              observer.disconnect();
            }
          });
          observer.observe(document.body, { childList: true, subtree: true });
          
          const interval = setInterval(function() {
            attempts++;
            if (fixAppLink() || attempts >= maxAttempts) {
              clearInterval(interval);
              observer.disconnect();
            }
          }, 100);
        }
      })();
      
      // Persist expanded search bar with typed text and closeup state
      (function() {
        const urlParams = new URLSearchParams(window.location.search);
        const searchQuery = urlParams.get('q') || '';
        let searchBar = null;
        let input = null;
        let isInitialized = false;
        
        function maintainSearchBarState() {
          searchBar = document.querySelector('.SearchBar-module__searchBar');
          if (searchBar) {
            // Always maintain expanded state
            if (!searchBar.classList.contains('SearchBar-module__expanded')) {
              searchBar.classList.add('SearchBar-module__expanded');
            }
            
            // Maintain closeup state if there's a query
            if (searchQuery) {
              if (!searchBar.classList.contains('SearchBar-module__closeup')) {
                searchBar.classList.add('SearchBar-module__closeup');
              }
              if (searchBar.getAttribute('data-closeup-context-visible') !== 'true') {
                searchBar.setAttribute('data-closeup-context-visible', 'true');
              }
            }
            
            // Set input value
            input = searchBar.querySelector('input');
            if (input) {
              if (input.value !== searchQuery) {
                input.value = searchQuery;
              }
              
              // Ensure input is editable - remove all restrictions
              input.readOnly = false;
              input.removeAttribute('readonly');
              input.removeAttribute('disabled');
              input.disabled = false;
              input.style.pointerEvents = 'auto';
              input.style.userSelect = 'auto';
              input.style.cursor = 'text';
              input.setAttribute('contenteditable', 'true');
              
              // Add margin-left for spacing from avatar
              input.style.marginLeft = '12px';
              
              // Add Enter key handler
              if (!input.hasAttribute('data-enter-handler-added')) {
                input.addEventListener('keydown', function(e) {
                  if (e.key === 'Enter' || e.keyCode === 13) {
                    e.preventDefault();
                    const currentQuery = input.value || '';
                    window.location.href = '/results-page.html?q=' + encodeURIComponent(currentQuery);
                  }
                });
                input.setAttribute('data-enter-handler-added', 'true');
              }
              
              // Update closeup state when input changes
              if (!input.hasAttribute('data-input-handler-added')) {
                input.addEventListener('input', function() {
                  if (input.value) {
                    if (!searchBar.classList.contains('SearchBar-module__closeup')) {
                      searchBar.classList.add('SearchBar-module__closeup');
                    }
                    searchBar.setAttribute('data-closeup-context-visible', 'true');
                  } else {
                    if (searchBar.classList.contains('SearchBar-module__closeup')) {
                      searchBar.classList.remove('SearchBar-module__closeup');
                    }
                    searchBar.removeAttribute('data-closeup-context-visible');
                  }
                });
                input.setAttribute('data-input-handler-added', 'true');
              }
              
              if (!isInitialized) {
                input.focus();
                isInitialized = true;
              }
            }
          }
        }
        
        // Continuously maintain state to override React's changes
        function startMaintainingState() {
          maintainSearchBarState();
          
          // Watch for class/attribute changes and re-apply
          const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
              if (mutation.type === 'attributes' && mutation.target === searchBar) {
                if (mutation.attributeName === 'class') {
                  maintainSearchBarState();
                } else if (mutation.attributeName === 'data-closeup-context-visible') {
                  maintainSearchBarState();
                }
              }
            });
            maintainSearchBarState();
          });
          
          // Observe the search bar for changes
          if (searchBar) {
            observer.observe(searchBar, {
              attributes: true,
              attributeFilter: ['class', 'data-closeup-context-visible'],
              childList: true,
              subtree: true
            });
          }
          
          // Also observe body for when search bar is added/removed
          const bodyObserver = new MutationObserver(function() {
            maintainSearchBarState();
          });
          bodyObserver.observe(document.body, {
            childList: true,
            subtree: true
          });
          
          // Continuously check and maintain state
          setInterval(function() {
            maintainSearchBarState();
            // Also ensure input remains editable
            const input = searchBar ? searchBar.querySelector('input') : null;
            if (input) {
              input.readOnly = false;
              input.removeAttribute('readonly');
              input.removeAttribute('disabled');
              input.disabled = false;
              input.style.pointerEvents = 'auto';
              input.style.userSelect = 'auto';
              input.style.cursor = 'text';
              input.style.marginLeft = '12px';
            }
          }, 100);
        }
        
        // Wait for React to render, then start maintaining state
        let attempts = 0;
        const maxAttempts = 100;
        const checkInterval = setInterval(function() {
          attempts++;
          if (document.querySelector('.SearchBar-module__searchBar') || attempts >= maxAttempts) {
            clearInterval(checkInterval);
            startMaintainingState();
          }
        }, 100);
      })();
      
      // Replace SearchBar-module__searchIconContainer with boards-avatar copy (same as boards.html)
      (function() {
        let attempts = 0;
        const maxAttempts = 100;
        
        function replaceSearchIcon() {
          const searchIconContainer = document.querySelector('.SearchBar-module__searchIconContainer');
          if (searchIconContainer) {
            // Check if avatar already exists
            const existingAvatar = searchIconContainer.querySelector('img[src="/assets/avatar/avatar.png"]');
            if (existingAvatar) return true;
            
            // Create avatar image matching boards-avatar styling
            const avatarImg = document.createElement('img');
            avatarImg.src = '/assets/avatar/avatar.png';
            avatarImg.alt = 'Avatar';
            avatarImg.style.width = '48px';
            avatarImg.style.height = '48px';
            avatarImg.style.minWidth = '48px';
            avatarImg.style.maxWidth = '48px';
            avatarImg.style.borderRadius = '50%';
            avatarImg.style.objectFit = 'cover';
            avatarImg.style.display = 'block';
            avatarImg.style.visibility = 'visible';
            avatarImg.style.opacity = '1';
            avatarImg.style.flexShrink = '0';
            
            // Replace the container's content with the avatar
            searchIconContainer.innerHTML = '';
            searchIconContainer.appendChild(avatarImg);
            
            // Ensure container maintains proper sizing and visibility (override closeup state)
            searchIconContainer.style.width = '48px';
            searchIconContainer.style.height = '48px';
            searchIconContainer.style.minWidth = '48px';
            searchIconContainer.style.maxWidth = '48px';
            searchIconContainer.style.display = 'flex';
            searchIconContainer.style.alignItems = 'center';
            searchIconContainer.style.justifyContent = 'center';
            searchIconContainer.style.visibility = 'visible';
            searchIconContainer.style.opacity = '1';
            searchIconContainer.style.overflow = 'visible';
            searchIconContainer.style.transform = 'scale(1)';
            return true;
          }
          return false;
        }
        
        // Continuously check and replace to override React's changes
        function startReplacing() {
          replaceSearchIcon();
          
          const observer = new MutationObserver(function() {
            replaceSearchIcon();
          });
          observer.observe(document.body, { childList: true, subtree: true, attributes: true });
          
          setInterval(replaceSearchIcon, 100);
        }
        
        if (!replaceSearchIcon()) {
          const checkInterval = setInterval(function() {
            attempts++;
            if (replaceSearchIcon() || attempts >= maxAttempts) {
              clearInterval(checkInterval);
              startReplacing();
            }
          }, 100);
        } else {
          startReplacing();
        }
      })();
    </script>
    <div class="app-container">
      <div class="MasonryGrid-module__container">
        <div class="MasonryGrid-module__gridContainer packery-container">
        </div>
      </div>
    </div>
    <script>
      // Find image-result and add it to MasonryGrid, then initialize masonry layout
      (function() {
        let imageResult = null;
        let gridContainer = null;
        let attempts = 0;
        const maxAttempts = 100;
        
        function findAndMoveImageResult() {
          // Find image-result element - try multiple selectors
          if (!imageResult) {
            // Try exact matches first
            imageResult = document.querySelector('#image-result') || 
                         document.querySelector('.image-result') ||
                         document.querySelector('[id="image-result"]') ||
                         document.querySelector('[class="image-result"]');
            
            // Try partial matches
            if (!imageResult) {
              imageResult = document.querySelector('[id*="image-result"]') || 
                           document.querySelector('[class*="image-result"]') ||
                           document.querySelector('[id*="imageResult"]') ||
                           document.querySelector('[class*="imageResult"]');
            }
            
            // Also try to find it by searching all elements
            if (!imageResult) {
              const allElements = document.querySelectorAll('*');
              for (let el of allElements) {
                const id = el.id ? el.id.toLowerCase() : '';
                const className = el.className ? (typeof el.className === 'string' ? el.className.toLowerCase() : Array.from(el.className).join(' ').toLowerCase()) : '';
                if ((id.includes('image') && id.includes('result')) || 
                    (className.includes('image') && className.includes('result'))) {
                  imageResult = el;
                  break;
                }
              }
            }
          }
          
          // Find grid container
          if (!gridContainer) {
            gridContainer = document.querySelector('.MasonryGrid-module__gridContainer.packery-container');
          }
          
          // If both found and image-result is not already in the grid, move it
          if (imageResult && gridContainer && !gridContainer.contains(imageResult)) {
            // Create a grid item wrapper if needed
            let gridItem = imageResult.closest('.MasonryGrid-module__gridItem');
            if (!gridItem) {
              gridItem = document.createElement('div');
              gridItem.className = 'MasonryGrid-module__gridItem';
              // Insert before image-result
              if (imageResult.parentNode) {
                imageResult.parentNode.insertBefore(gridItem, imageResult);
              }
              gridItem.appendChild(imageResult);
            }
            
            // Move to grid container as first child
            gridContainer.insertBefore(gridItem, gridContainer.firstChild);
            return true;
          }
          
          return false;
        }
        
        // Simple masonry grid implementation for image pins
        function initMasonryGrid() {
          const gridContainer = document.querySelector('.MasonryGrid-module__gridContainer.packery-container');
          if (!gridContainer) return;
          
          // Responsive breakpoints (same as boards.html)
          const breakpoints = [
            { min: 1372, cols: 5 },
            { min: 1115, cols: 4 },
            { min: 860, cols: 3 },
            { min: 500, cols: 2 }
          ];
          
          function getColumnCount() {
            const width = window.innerWidth;
            for (const bp of breakpoints) {
              if (width >= bp.min) {
                return bp.cols;
              }
            }
            return 1;
          }
          
          function calculateColumnWidth(containerWidth, columnCount, gutter) {
            const totalGutters = gutter * (columnCount - 1);
            return (containerWidth - totalGutters) / columnCount;
          }
          
          function layoutGrid() {
            const windowWidth = window.innerWidth;
            // Match index.html styling - no left/right margins for container
            const containerWidth = windowWidth;
            const columnCount = getColumnCount();
            const gutter = 16;
            const columnWidth = calculateColumnWidth(containerWidth, columnCount, gutter);
            
            const gridItems = gridContainer.querySelectorAll('.MasonryGrid-module__gridItem');
            const columnHeights = Array(columnCount).fill(0);
            
            gridItems.forEach((item) => {
              // Get the actual content (pin or image-result)
              const pin = item.querySelector('.Pin-module__pin, [class*="Pin-module"], img, [id*="image-result"], [class*="image-result"]') || item.firstElementChild;
              if (!pin) return;
              
              // Get natural dimensions
              let itemWidth = columnWidth;
              let itemHeight = 0;
              
              // Check if this is image-result to preserve its dimensions
              const isImageResult = pin.id && pin.id.includes('image-result') || 
                                   pin.className && (typeof pin.className === 'string' ? pin.className.includes('image-result') : Array.from(pin.className).some(c => c.includes('image-result')));
              
              // Try to get natural height from image or computed style
              if (pin.tagName === 'IMG') {
                const img = pin;
                if (img.naturalHeight && img.naturalWidth) {
                  const aspectRatio = img.naturalHeight / img.naturalWidth;
                  itemHeight = itemWidth * aspectRatio;
                } else if (img.offsetHeight && img.offsetWidth && img.offsetWidth > 0) {
                  const aspectRatio = img.offsetHeight / img.offsetWidth;
                  itemHeight = itemWidth * aspectRatio;
                } else {
                  // Default aspect ratio for pins (2:3)
                  itemHeight = itemWidth * 1.5;
                }
              } else {
                // For other elements, try to get computed height or use aspect ratio
                if (isImageResult && pin.offsetHeight && pin.offsetWidth && pin.offsetWidth > 0) {
                  // For image-result, preserve its aspect ratio
                  const aspectRatio = pin.offsetHeight / pin.offsetWidth;
                  itemHeight = itemWidth * aspectRatio;
                } else {
                  const aspectRatioAttr = pin.getAttribute('data-aspect-ratio') || 
                                         (pin.classList.contains('Pin-module__ratio2_3') ? 1.5 :
                                          pin.classList.contains('Pin-module__ratio1_1') ? 1 :
                                          pin.classList.contains('Pin-module__ratio3_4') ? 1.333 : 1.5);
                  
                  if (pin.offsetHeight && pin.offsetWidth && pin.offsetWidth > 0) {
                    const currentAspectRatio = pin.offsetHeight / pin.offsetWidth;
                    itemHeight = itemWidth * currentAspectRatio;
                  } else {
                    itemHeight = itemWidth * parseFloat(aspectRatioAttr);
                  }
                }
              }
              
              // Set item width and position (only on wrapper, not on image-result itself)
              item.style.width = columnWidth + 'px';
              item.style.position = 'absolute';
              
              // Set pin width if it exists (preserve other styles)
              if (pin) {
                // Only set width if not already set or if it's a standard pin
                const isImageResult = pin.id && pin.id.includes('image-result') || 
                                     pin.className && (typeof pin.className === 'string' ? pin.className.includes('image-result') : Array.from(pin.className).some(c => c.includes('image-result')));
                
                if (!isImageResult) {
                  // For standard pins, set width to fit column
                  pin.style.width = '100%';
                  if (pin.tagName === 'IMG') {
                    pin.style.height = 'auto';
                  }
                } else {
                  // For image-result, preserve its styling but ensure it fits within wrapper
                  const currentWidth = pin.style.width || window.getComputedStyle(pin).width;
                  if (!currentWidth || currentWidth === 'auto' || parseFloat(currentWidth) > columnWidth) {
                    pin.style.maxWidth = '100%';
                  }
                }
              }
              
              // Find shortest column
              const shortestColumn = columnHeights.indexOf(Math.min(...columnHeights));
              
              // Position item
              const x = shortestColumn * (columnWidth + gutter);
              const y = columnHeights[shortestColumn];
              
              item.style.left = x + 'px';
              item.style.top = y + 'px';
              
              // Update column height (add item height + gutter)
              columnHeights[shortestColumn] += itemHeight + gutter;
            });
            
            // Set container height
            const maxHeight = Math.max(...columnHeights, 0);
            gridContainer.style.height = maxHeight + 'px';
          }
          
          // Wait for items to be added, then layout
          function checkAndLayout() {
            const gridItems = gridContainer.querySelectorAll('.MasonryGrid-module__gridItem');
            if (gridItems.length > 0) {
              // Wait a bit for images to load
              setTimeout(() => {
                layoutGrid();
              }, 100);
            }
          }
          
          // Initialize on load
          checkAndLayout();
          
          // Reinitialize on resize with debounce
          let resizeTimeout;
          window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              layoutGrid();
            }, 250);
          });
          
          // Watch for new items being added
          const observer = new MutationObserver(() => {
            checkAndLayout();
          });
          observer.observe(gridContainer, {
            childList: true,
            subtree: true
          });
        }
        
        // Try to find and move image-result, then initialize grid
        function setupMasonryGrid() {
          if (findAndMoveImageResult() || attempts < maxAttempts) {
            attempts++;
            // Initialize masonry grid
            setTimeout(() => {
              initMasonryGrid();
            }, 100);
            
            // Continue trying to find image-result if not found yet
            if (!imageResult && attempts < maxAttempts) {
              setTimeout(setupMasonryGrid, 100);
            }
          }
        }
        
        // Start setup
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', setupMasonryGrid);
        } else {
          setupMasonryGrid();
        }
        
        // Also watch for DOM changes to catch React-rendered content
        const bodyObserver = new MutationObserver(() => {
          if (!imageResult || !gridContainer || !gridContainer.contains(imageResult)) {
            findAndMoveImageResult();
            setTimeout(initMasonryGrid, 100);
          }
        });
        bodyObserver.observe(document.body, {
          childList: true,
          subtree: true
        });
      })();
    </script>
  </body>
</html>
