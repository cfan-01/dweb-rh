<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Results - Pinterest</title>
    <link rel="icon" href="/dweb-rh/favicon.ico" />
    <link rel="stylesheet" crossorigin href="/dweb-rh/assets/index-I0l3_rlN.css">
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: var(--color-background);
        font-family: var(--font-family-pin-sans);
        display: flex;
        min-height: 100vh;
      }
      .app-container {
        display: flex;
        width: 100%;
        min-height: 100vh;
        /* Add margin to account for fixed GlobalNav + 16px gap */
        margin-left: calc(var(--global-nav-width, 80px) + 16px) !important;
      }
      .App-module__main {
        display: none !important;
      }
      .SearchBar-module__searchBar.SearchBar-module__closeup[data-closeup-context-visible="true"] .SearchBar-module__searchIconContainer {
        width: 48px !important;
        height: 48px !important;
        transform: scale(1) !important;
        opacity: 1 !important;
        visibility: visible !important;
      }
      .SearchBar-module__searchInput {
        margin-left: 12px !important;
        pointer-events: auto !important;
        user-select: auto !important;
        cursor: text !important;
      }
      .SearchBar-module__searchInput[readonly],
      .SearchBar-module__searchInput[disabled] {
        pointer-events: auto !important;
        user-select: auto !important;
        cursor: text !important;
      }
      .IconButton-module__iconButton[aria-current="page"],
      .IconButton-module__iconButton[aria-selected="true"],
      .IconButton-module__iconButton.active,
      .IconButton-module__iconButton[data-active="true"] {
        background-color: #000000 !important;
        border-radius: 8px !important;
        padding: 8px 12px !important;
      }
      .IconButton-module__iconButton[aria-current="page"] svg,
      .IconButton-module__iconButton[aria-current="page"] svg path,
      .IconButton-module__iconButton[aria-selected="true"] svg,
      .IconButton-module__iconButton[aria-selected="true"] svg path,
      .IconButton-module__iconButton.active svg,
      .IconButton-module__iconButton.active svg path,
      .IconButton-module__iconButton[data-active="true"] svg,
      .IconButton-module__iconButton[data-active="true"] svg path {
        fill: #ffffff !important;
        color: #ffffff !important;
      }
      .MasonryGrid-module__gridContainer {
        margin-top: 16px !important;
        margin-left: 0 !important;
        margin-right: 16px !important;
        position: relative !important;
      }
      .GlobalNav-module__globalNav {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        height: 100vh !important;
        z-index: 200 !important;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script>
      // Fix asset paths for GitHub Pages (same as index.html)
      (function() {
        const basePath = '/dweb-rh';
        const maxImageNumber = 21; // We only have hf-1.jpg through hf-21.jpg
        
        // Map missing image numbers to existing ones and fix extensions
        function getValidImagePath(requestedPath) {
          if (!requestedPath) return null;
          const match = requestedPath.match(/hf-(\d+)\.(jpg|webp|png)/i);
          if (match) {
            const requestedNum = parseInt(match[1], 10);
            const originalExtension = match[2].toLowerCase();
            const validNum = requestedNum > maxImageNumber 
              ? ((requestedNum - 1) % maxImageNumber) + 1 
              : requestedNum;
            let fixedPath = requestedPath.replace(/hf-\d+\.(jpg|webp|png)/i, `hf-${validNum}.jpg`);
            return fixedPath;
          }
          return null;
        }
        
        function fixPathAndImageNumber(path) {
          if (!path || typeof path !== 'string') return path;
          let fixedPath = path;
          try {
            const url = new URL(path, window.location.origin);
            fixedPath = url.pathname;
          } catch(e) {
            if (path.startsWith('/')) {
              fixedPath = path;
            }
          }
          if (fixedPath && fixedPath.startsWith('/assets/') && !fixedPath.startsWith(basePath)) {
            fixedPath = basePath + fixedPath;
          }
          const validPath = getValidImagePath(fixedPath);
          if (validPath) {
            fixedPath = validPath;
          }
          return fixedPath;
        }
        
        // Override src property setter on HTMLImageElement prototype
        const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
        if (originalSrcDescriptor && originalSrcDescriptor.set) {
          const originalSet = originalSrcDescriptor.set;
          Object.defineProperty(HTMLImageElement.prototype, 'src', {
            set: function(value) {
              if (value && typeof value === 'string') {
                const fixedPath = fixPathAndImageNumber(value);
                if (fixedPath !== value) {
                  value = fixedPath;
                }
              }
              originalSet.call(this, value);
            },
            get: originalSrcDescriptor.get,
            configurable: true,
            enumerable: true
          });
        }
        
        // Override setAttribute for images
        const originalSetAttribute = Element.prototype.setAttribute;
        Element.prototype.setAttribute = function(name, value) {
          if (this.tagName === 'IMG' && (name === 'src' || name === 'data-src' || name === 'data-lazy-src')) {
            if (value && typeof value === 'string') {
              const fixedPath = fixPathAndImageNumber(value);
              if (fixedPath !== value) {
                value = fixedPath;
              }
            }
          }
          return originalSetAttribute.call(this, name, value);
        };
        
        // Fix font paths in CSS
        function fixFontPaths() {
          try {
            const styleSheets = document.styleSheets;
            for (let i = 0; i < styleSheets.length; i++) {
              try {
                const rules = styleSheets[i].cssRules || styleSheets[i].rules;
                if (rules) {
                  for (let j = 0; j < rules.length; j++) {
                    const rule = rules[j];
                    if (rule instanceof CSSFontFaceRule && rule.style && rule.style.src) {
                      let src = rule.style.src;
                      if (src && src.includes('/assets/') && !src.includes(basePath)) {
                        src = src.replace(/\/assets\//g, basePath + '/assets/');
                        rule.style.src = src;
                      }
                    }
                  }
                }
              } catch(e) {
                // Cross-origin stylesheet, skip
              }
            }
          } catch(e) {
            // Ignore errors
          }
        }
        
        // Fix fonts on load and watch for new stylesheets
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', fixFontPaths);
        } else {
          fixFontPaths();
        }
        
        const styleObserver = new MutationObserver(() => {
          fixFontPaths();
        });
        styleObserver.observe(document.head, { childList: true, subtree: true });
        
        // Also fix fonts periodically
        setInterval(fixFontPaths, 500);
        
        // Intercept image error events
        document.addEventListener('error', function(e) {
          if (e.target && e.target.tagName === 'IMG') {
            const img = e.target;
            let src = img.src || img.getAttribute('src') || '';
            try {
              const url = new URL(src, window.location.origin);
              src = url.pathname;
            } catch(e) {}
            const fixedPath = fixPathAndImageNumber(src);
            if (fixedPath && fixedPath !== src) {
              img.src = fixedPath;
              if (img.getAttribute('src')) img.setAttribute('src', fixedPath);
            }
          }
        }, true);
      })();
    </script>
    <script type="module" crossorigin src="/dweb-rh/assets/index-BLL-NyY1.js"></script>
    <script>
      // Fix App-module__app link to home page
      (function() {
        let attempts = 0;
        const maxAttempts = 50;
        
        function fixAppLink() {
          const appLink = document.querySelector('.App-module__app');
          if (appLink) {
            // If it's already an anchor tag, set href
            if (appLink.tagName === 'A') {
              appLink.href = '/dweb-rh/index.html';
              appLink.setAttribute('href', '/dweb-rh/index.html');
            } else {
              // If it's a button or div, make it clickable
              appLink.style.cursor = 'pointer';
              appLink.addEventListener('click', function(e) {
                e.preventDefault();
                window.location.href = '/dweb-rh/index.html';
              });
            }
            return true;
          }
          return false;
        }
        
        if (!fixAppLink()) {
          const observer = new MutationObserver(function() {
            attempts++;
            if (fixAppLink() || attempts >= maxAttempts) {
              observer.disconnect();
            }
          });
          observer.observe(document.body, { childList: true, subtree: true });
          
          const interval = setInterval(function() {
            attempts++;
            if (fixAppLink() || attempts >= maxAttempts) {
              clearInterval(interval);
              observer.disconnect();
            }
          }, 100);
        }
      })();
      
      // Persist expanded search bar with typed text and closeup state
      (function() {
        const urlParams = new URLSearchParams(window.location.search);
        const searchQuery = urlParams.get('q') || '';
        let searchBar = null;
        let input = null;
        let isInitialized = false;
        
        function maintainSearchBarState() {
          searchBar = document.querySelector('.SearchBar-module__searchBar');
          if (searchBar) {
            // Always maintain expanded state
            if (!searchBar.classList.contains('SearchBar-module__expanded')) {
              searchBar.classList.add('SearchBar-module__expanded');
            }
            
            // Maintain closeup state if there's a query
            if (searchQuery) {
              if (!searchBar.classList.contains('SearchBar-module__closeup')) {
                searchBar.classList.add('SearchBar-module__closeup');
              }
              if (searchBar.getAttribute('data-closeup-context-visible') !== 'true') {
                searchBar.setAttribute('data-closeup-context-visible', 'true');
              }
            }
            
            // Set input value
            input = searchBar.querySelector('input');
            if (input) {
              if (input.value !== searchQuery) {
                input.value = searchQuery;
              }
              
              // Ensure input is editable - remove all restrictions
              input.readOnly = false;
              input.removeAttribute('readonly');
              input.removeAttribute('disabled');
              input.disabled = false;
              input.style.pointerEvents = 'auto';
              input.style.userSelect = 'auto';
              input.style.cursor = 'text';
              input.setAttribute('contenteditable', 'true');
              
              // Add margin-left for spacing from avatar
              input.style.marginLeft = '12px';
              
              // Add Enter key handler
              if (!input.hasAttribute('data-enter-handler-added')) {
                input.addEventListener('keydown', function(e) {
                  if (e.key === 'Enter' || e.keyCode === 13) {
                    e.preventDefault();
                    const currentQuery = input.value || '';
                    window.location.href = '/results-page.html?q=' + encodeURIComponent(currentQuery);
                  }
                });
                input.setAttribute('data-enter-handler-added', 'true');
              }
              
              // Update closeup state when input changes
              if (!input.hasAttribute('data-input-handler-added')) {
                input.addEventListener('input', function() {
                  if (input.value) {
                    if (!searchBar.classList.contains('SearchBar-module__closeup')) {
                      searchBar.classList.add('SearchBar-module__closeup');
                    }
                    searchBar.setAttribute('data-closeup-context-visible', 'true');
                  } else {
                    if (searchBar.classList.contains('SearchBar-module__closeup')) {
                      searchBar.classList.remove('SearchBar-module__closeup');
                    }
                    searchBar.removeAttribute('data-closeup-context-visible');
                  }
                });
                input.setAttribute('data-input-handler-added', 'true');
              }
              
              if (!isInitialized) {
                input.focus();
                isInitialized = true;
              }
            }
          }
        }
        
        // Continuously maintain state to override React's changes
        function startMaintainingState() {
          maintainSearchBarState();
          
          // Watch for class/attribute changes and re-apply
          const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
              if (mutation.type === 'attributes' && mutation.target === searchBar) {
                if (mutation.attributeName === 'class') {
                  maintainSearchBarState();
                } else if (mutation.attributeName === 'data-closeup-context-visible') {
                  maintainSearchBarState();
                }
              }
            });
            maintainSearchBarState();
          });
          
          // Observe the search bar for changes
          if (searchBar) {
            observer.observe(searchBar, {
              attributes: true,
              attributeFilter: ['class', 'data-closeup-context-visible'],
              childList: true,
              subtree: true
            });
          }
          
          // Also observe body for when search bar is added/removed
          const bodyObserver = new MutationObserver(function() {
            maintainSearchBarState();
          });
          bodyObserver.observe(document.body, {
            childList: true,
            subtree: true
          });
          
          // Continuously check and maintain state
          setInterval(function() {
            maintainSearchBarState();
            // Also ensure input remains editable
            const input = searchBar ? searchBar.querySelector('input') : null;
            if (input) {
              input.readOnly = false;
              input.removeAttribute('readonly');
              input.removeAttribute('disabled');
              input.disabled = false;
              input.style.pointerEvents = 'auto';
              input.style.userSelect = 'auto';
              input.style.cursor = 'text';
              input.style.marginLeft = '12px';
            }
          }, 100);
        }
        
        // Wait for React to render, then start maintaining state
        let attempts = 0;
        const maxAttempts = 100;
        const checkInterval = setInterval(function() {
          attempts++;
          if (document.querySelector('.SearchBar-module__searchBar') || attempts >= maxAttempts) {
            clearInterval(checkInterval);
            startMaintainingState();
          }
        }, 100);
      })();
      
      // Replace SearchBar-module__searchIconContainer with boards-avatar copy (same as boards.html)
      (function() {
        let attempts = 0;
        const maxAttempts = 100;
        
        function replaceSearchIcon() {
          const searchIconContainer = document.querySelector('.SearchBar-module__searchIconContainer');
          if (searchIconContainer) {
            // Check if avatar already exists
            const existingAvatar = searchIconContainer.querySelector('img[src="/dweb-rh/assets/avatar/avatar.png"]');
            if (existingAvatar) return true;
            
            // Create avatar image matching boards-avatar styling
            const avatarImg = document.createElement('img');
            avatarImg.src = '/dweb-rh/assets/avatar/avatar.png';
            avatarImg.alt = 'Avatar';
            avatarImg.style.width = '48px';
            avatarImg.style.height = '48px';
            avatarImg.style.minWidth = '48px';
            avatarImg.style.maxWidth = '48px';
            avatarImg.style.borderRadius = '50%';
            avatarImg.style.objectFit = 'cover';
            avatarImg.style.display = 'block';
            avatarImg.style.visibility = 'visible';
            avatarImg.style.opacity = '1';
            avatarImg.style.flexShrink = '0';
            
            // Replace the container's content with the avatar
            searchIconContainer.innerHTML = '';
            searchIconContainer.appendChild(avatarImg);
            
            // Ensure container maintains proper sizing and visibility (override closeup state)
            searchIconContainer.style.width = '48px';
            searchIconContainer.style.height = '48px';
            searchIconContainer.style.minWidth = '48px';
            searchIconContainer.style.maxWidth = '48px';
            searchIconContainer.style.display = 'flex';
            searchIconContainer.style.alignItems = 'center';
            searchIconContainer.style.justifyContent = 'center';
            searchIconContainer.style.visibility = 'visible';
            searchIconContainer.style.opacity = '1';
            searchIconContainer.style.overflow = 'visible';
            searchIconContainer.style.transform = 'scale(1)';
            return true;
          }
          return false;
        }
        
        // Continuously check and replace to override React's changes
        function startReplacing() {
          replaceSearchIcon();
          
          const observer = new MutationObserver(function() {
            replaceSearchIcon();
          });
          observer.observe(document.body, { childList: true, subtree: true, attributes: true });
          
          setInterval(replaceSearchIcon, 100);
        }
        
        if (!replaceSearchIcon()) {
          const checkInterval = setInterval(function() {
            attempts++;
            if (replaceSearchIcon() || attempts >= maxAttempts) {
              clearInterval(checkInterval);
              startReplacing();
            }
          }, 100);
        } else {
          startReplacing();
        }
      })();
      
      // Fix avatar image in GlobalNav AvatarButton
      (function() {
        let attempts = 0;
        const maxAttempts = 100;
        
        function fixGlobalNavAvatar() {
          const globalNav = document.querySelector('.GlobalNav-module__globalNav');
          if (!globalNav) return false;
          
          const avatarButton = globalNav.querySelector('.AvatarButton-module__avatarButton');
          if (!avatarButton) return false;
          
          // Find the image inside the avatar button
          let avatarImg = avatarButton.querySelector('img');
          
          // If no image exists, create one
          if (!avatarImg) {
            avatarImg = document.createElement('img');
            avatarButton.appendChild(avatarImg);
          }
          
          // Set the image source and make it visible
          avatarImg.src = '/dweb-rh/assets/avatar/avatar.png';
          avatarImg.alt = 'Avatar';
          avatarImg.style.display = 'block';
          avatarImg.style.visibility = 'visible';
          avatarImg.style.opacity = '1';
          avatarImg.style.width = '28px';
          avatarImg.style.height = '28px';
          avatarImg.style.borderRadius = '50%';
          avatarImg.style.objectFit = 'cover';
          
          return true;
        }
        
        // Try immediately
        if (!fixGlobalNavAvatar()) {
          const observer = new MutationObserver(function() {
            attempts++;
            if (fixGlobalNavAvatar() || attempts >= maxAttempts) {
              observer.disconnect();
            }
          });
          observer.observe(document.body, { childList: true, subtree: true });
          
          const interval = setInterval(function() {
            attempts++;
            if (fixGlobalNavAvatar() || attempts >= maxAttempts) {
              clearInterval(interval);
              observer.disconnect();
            }
          }, 100);
        }
        
        // Also run periodically to catch React re-renders
        setInterval(fixGlobalNavAvatar, 1000);
      })();
      
      // Fix navigation links in GlobalNav
      (function() {
        let attempts = 0;
        const maxAttempts = 100;
        
        function findNavIcon(iconName) {
          const nav = document.querySelector('.GlobalNav-module__globalNav') || 
                     document.querySelector('[class*="GlobalNav"]');
          if (!nav) return null;
          
          const clickables = nav.querySelectorAll('button, [role="button"], a, div[class*="iconButton"], div[class*="IconButton"]');
          
          for (let el of clickables) {
            const text = (el.textContent || el.innerText || '').trim();
            const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();
            const title = (el.getAttribute('title') || '').toLowerCase();
            
            if (text === iconName || ariaLabel.includes(iconName.toLowerCase()) || title.includes(iconName.toLowerCase())) {
              return el;
            }
            
            const parent = el.parentElement;
            if (parent) {
              const parentText = (parent.textContent || parent.innerText || '').trim();
              if (parentText === iconName) {
                return parent;
              }
            }
          }
          
          // Alternative: look by position in leading section
          const leading = nav.querySelector('[class*="leading"]') || nav.querySelector('[class*="Leading"]');
          if (leading) {
            const icons = leading.querySelectorAll('button, [role="button"], a, div[class*="iconButton"], div[class*="IconButton"]');
            // Home is typically 2nd icon (index 1), Boards is 4th (index 3)
            if (iconName === 'Home' && icons.length >= 2) {
              return icons[1];
            } else if (iconName === 'Boards' && icons.length >= 4) {
              return icons[3];
            }
          }
          
          return null;
        }
        
        function attachNavHandlers() {
          // Fix Home icon
          const homeIcon = findNavIcon('Home');
          if (homeIcon && !homeIcon.hasAttribute('data-nav-handler-attached')) {
            homeIcon.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              window.location.href = '/dweb-rh/index.html';
              return false;
            });
            homeIcon.style.cursor = 'pointer';
            homeIcon.setAttribute('data-nav-handler-attached', 'true');
          }
          
          // Fix Boards icon
          const boardsIcon = findNavIcon('Boards');
          if (boardsIcon && !boardsIcon.hasAttribute('data-nav-handler-attached')) {
            boardsIcon.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              window.location.href = '/dweb-rh/boards.html';
              return false;
            });
            boardsIcon.style.cursor = 'pointer';
            boardsIcon.setAttribute('data-nav-handler-attached', 'true');
          }
        }
        
        // Try immediately
        attachNavHandlers();
        
        // Use MutationObserver to watch for DOM changes
        const observer = new MutationObserver(function() {
          attempts++;
          attachNavHandlers();
          if (attempts >= maxAttempts) {
            observer.disconnect();
          }
        });
        
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
        
        // Also try on intervals as fallback
        const interval = setInterval(function() {
          attempts++;
          attachNavHandlers();
          if (attempts >= maxAttempts) {
            clearInterval(interval);
            observer.disconnect();
          }
        }, 100);
        
        // Keep checking periodically to catch React re-renders
        setInterval(attachNavHandlers, 1000);
      })();
      
      // Set GlobalNav width as CSS variable and apply margin to app-container
      (function() {
        function setGlobalNavWidth() {
          const globalNav = document.querySelector('.GlobalNav-module__globalNav');
          const appContainer = document.querySelector('.app-container');
          const masonryContainer = document.querySelector('.MasonryGrid-module__container');
          
          if (globalNav) {
            const width = globalNav.offsetWidth || 80;
            const marginValue = width + 16; // GlobalNav width + 16px gap
            document.documentElement.style.setProperty('--global-nav-width', width + 'px');
            
            // Apply margin to app-container only
            if (appContainer) {
              appContainer.style.marginLeft = marginValue + 'px';
            }
          }
        }
        
        // Run immediately and also wait for DOM
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', setGlobalNavWidth);
        } else {
          setGlobalNavWidth();
        }
        
        const observer = new MutationObserver(setGlobalNavWidth);
        observer.observe(document.body, { childList: true, subtree: true });
        window.addEventListener('resize', setGlobalNavWidth);
        // Also check periodically to catch React re-renders
        setInterval(setGlobalNavWidth, 100);
      })();
    </script>
    <div class="app-container">
      <div class="MasonryGrid-module__container">
        <div class="MasonryGrid-module__gridContainer packery-container">
          <div class="MasonryGrid-module__gridItem">
            <div class="Pin-module__pin Pin-module__ratio2_3">
              <img src="/dweb-rh/assets/images/hf-4.jpg" alt="Pin" class="Pin-module__pinImage" />
            </div>
          </div>
          <div class="MasonryGrid-module__gridItem">
            <div class="Pin-module__pin Pin-module__ratio2_3">
              <img src="/dweb-rh/assets/images/hf-16.jpg" alt="Pin" class="Pin-module__pinImage" />
            </div>
          </div>
          <div class="MasonryGrid-module__gridItem">
            <div class="Pin-module__pin Pin-module__ratio2_3">
              <img src="/dweb-rh/assets/images/hf-21.jpg" alt="Pin" class="Pin-module__pinImage" />
            </div>
          </div>
          <div class="MasonryGrid-module__gridItem">
            <div class="Pin-module__pin Pin-module__ratio2_3">
              <img src="/dweb-rh/assets/images/hf-11.jpg" alt="Pin" class="Pin-module__pinImage" />
            </div>
          </div>
          <div class="MasonryGrid-module__gridItem">
            <div class="Pin-module__pin Pin-module__ratio2_3">
              <img src="/dweb-rh/assets/images/hf-13.jpg" alt="Pin" class="Pin-module__pinImage" />
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      // Masonry grid implementation (same as index.html)
      (function() {
        document.addEventListener('DOMContentLoaded', function() {
          function initMasonryGrid() {
            const gridContainer = document.querySelector('.MasonryGrid-module__gridContainer.packery-container');
            if (!gridContainer) return;
            
            // Responsive breakpoints
            const breakpoints = [
              { min: 1372, cols: 5 },
              { min: 1115, cols: 4 },
              { min: 860, cols: 3 },
              { min: 500, cols: 2 }
            ];
            
            function getColumnCount() {
              const width = window.innerWidth;
              for (const bp of breakpoints) {
                if (width >= bp.min) {
                  return bp.cols;
                }
              }
              return 1;
            }
            
            function calculateColumnWidth(containerWidth, columnCount, gutter) {
              const totalGutters = gutter * (columnCount - 1);
              return (containerWidth - totalGutters) / columnCount;
            }
            
            function layoutGrid() {
              // Calculate available width: use actual container width minus right margin
              const container = gridContainer.closest('.MasonryGrid-module__container');
              const containerWidth = container ? container.offsetWidth : window.innerWidth;
              // Account for right margin (16px) on gridContainer
              const availableWidth = containerWidth - 16;
              const columnCount = getColumnCount();
              const gutter = 16;
              const columnWidth = calculateColumnWidth(availableWidth, columnCount, gutter);
              
              const gridItems = gridContainer.querySelectorAll('.MasonryGrid-module__gridItem');
              // Limit to 5 images
              const itemsToLayout = Array.from(gridItems).slice(0, 5);
              const columnHeights = Array(columnCount).fill(0);
              
              // First pass: set widths and calculate heights
              const itemHeights = [];
              itemsToLayout.forEach((item, index) => {
                const pin = item.querySelector('.Pin-module__pin');
                if (!pin) {
                  itemHeights[index] = 0;
                  return;
                }
                
                const img = pin.querySelector('img');
                if (!img) {
                  itemHeights[index] = 0;
                  return;
                }
                
                // Set item width first
                item.style.width = columnWidth + 'px';
                item.style.position = 'absolute';
                pin.style.width = '100%';
                
                // Calculate height based on image aspect ratio
                let itemHeight = 0;
                if (img.complete && img.naturalHeight && img.naturalWidth && img.naturalWidth > 0) {
                  const aspectRatio = img.naturalHeight / img.naturalWidth;
                  itemHeight = columnWidth * aspectRatio;
                } else if (img.offsetHeight && img.offsetWidth && img.offsetWidth > 0) {
                  const aspectRatio = img.offsetHeight / img.offsetWidth;
                  itemHeight = columnWidth * aspectRatio;
                } else {
                  // Default aspect ratio for pins (2:3)
                  const aspectRatio = pin.classList.contains('Pin-module__ratio2_3') ? 1.5 :
                                     pin.classList.contains('Pin-module__ratio1_1') ? 1 :
                                     pin.classList.contains('Pin-module__ratio3_4') ? 1.333 : 1.5;
                  itemHeight = columnWidth * aspectRatio;
                }
                
                itemHeights[index] = itemHeight;
              });
              
              // Second pass: position items
              itemsToLayout.forEach((item, index) => {
                if (itemHeights[index] === 0) return;
                
                const itemHeight = itemHeights[index];
                
                // Find shortest column
                const shortestColumn = columnHeights.indexOf(Math.min(...columnHeights));
                
                // Position item
                const x = shortestColumn * (columnWidth + gutter);
                const y = columnHeights[shortestColumn];
                
                item.style.left = x + 'px';
                item.style.top = y + 'px';
                
                // Update column height (add item height + gutter)
                columnHeights[shortestColumn] += itemHeight + gutter;
              });
              
              // Set container height
              const maxHeight = Math.max(...columnHeights, 0);
              gridContainer.style.height = maxHeight + 'px';
            }
            
            // Wait for images to load before initial layout
            function waitForImagesAndLayout() {
              const images = gridContainer.querySelectorAll('img');
              let loadedCount = 0;
              const totalImages = images.length;
              
              if (totalImages === 0) {
                layoutGrid();
                return;
              }
              
              function checkAndLayout() {
                loadedCount++;
                if (loadedCount === totalImages) {
                  // Wait a bit more for browser to calculate dimensions
                  setTimeout(() => {
                    layoutGrid();
                  }, 150);
                }
              }
              
              images.forEach(img => {
                if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
                  checkAndLayout();
                } else {
                  img.addEventListener('load', checkAndLayout, { once: true });
                  img.addEventListener('error', checkAndLayout, { once: true });
                }
              });
              
              // Fallback: layout after a timeout if images don't load
              setTimeout(() => {
                layoutGrid();
              }, 2000);
            }
            
            // Initialize after images load
            waitForImagesAndLayout();
            
            // Reinitialize on resize with debounce
            let resizeTimeout;
            window.addEventListener('resize', () => {
              clearTimeout(resizeTimeout);
              resizeTimeout = setTimeout(() => {
                layoutGrid();
              }, 250);
            });
            
            // Watch for new images being added
            const imageObserver = new MutationObserver(() => {
              const images = gridContainer.querySelectorAll('img');
              images.forEach(img => {
                if (!img.hasAttribute('data-layout-watched')) {
                  img.setAttribute('data-layout-watched', 'true');
                  if (!img.complete) {
                    img.addEventListener('load', () => {
                      setTimeout(layoutGrid, 100);
                    }, { once: true });
                  }
                }
              });
            });
            imageObserver.observe(gridContainer, {
              childList: true,
              subtree: true
            });
          }
          
          // Initialize masonry grid
          initMasonryGrid();
        });
      })();
    </script>
  </body>
</html>
